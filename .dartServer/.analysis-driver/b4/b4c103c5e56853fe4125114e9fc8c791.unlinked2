valuealphaopacityredgreenblue	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kIsAntiAliasOffset_kColorOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColorssRGBextendedSRGBrawRgbarawStraightRgbarawUnmodifiedrawExtendedRgba128pngrgba8888bgra8888rgbaFloat32_imageonCreate	onDispose_debugStackwidthheight	_disposeddisposedebugDisposed
toByteData
colorSpacedebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage
frameCountrepetitionCountgetNextFrame_cachedFrameCount_frameCount_cachedRepetitionCount_repetitionCount_getNextFramenonZeroevenOdd	intersectunionreverseDifferencefillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo
arcToPointrelativeArcToPointaddRectaddOvaladdArc
addPolygonaddRRectaddPathextendWithPathcloseresetcontainsshift	transform	getBoundscombinecomputeMetrics_constructor_clone_getFillType_setFillType_arcTo_arcToPoint_relativeArcToPoint_addRect_addOval_addArc_addPolygon	_addRRect_addPath_addPathWithMatrix_extendWithPath_extendWithPathAndMatrix	_contains_shift
_transform
_getBounds_oppositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlur_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringradiusXradiusYinnerFilterouterFilter	_initBlur_initDilate
_initErode_initColorFilter_initComposed_debugDisposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImage
_debugName	fromAsset_shaderRegistry_reinitializeShader_uniformFloatCount_samplerCount_initFromAssetfragmentShader_kEmptyFloat32List_floatssetFloatsetImageSampler_setImageSampler_validateSamplers	trianglestriangleStriptriangleFan_initpointslinespolygonsave	saveLayerrestorerestoreToCountgetSaveCount	translatescalerotateskewgetTransformclipRect	clipRRectclipPathgetLocalClipBoundsgetDestinationClipBounds	drawColordrawLine	drawPaintdrawRect	drawRRect
drawDRRectdrawOval
drawCircledrawArcdrawPath	drawImagedrawImageRectdrawImageNinedrawPicturedrawParagraph
drawPointsdrawRawPointsdrawVertices	drawAtlasdrawRawAtlas
drawShadow	_recorder_sorted_saveLayerWithoutBounds
_saveLayer_scale_getTransform	_clipRect
_clipRRect	_clipPath_getLocalClipBounds_getDestinationClipBounds
_drawColor	_drawLine
_drawPaint	_drawRect
_drawRRect_drawDRRect	_drawOval_drawCircle_drawArc	_drawPath
_drawImage_drawImageRect_drawImageNine_drawPicture_drawPoints_drawVertices
_drawAtlas_drawShadowtoImagetoImageSyncapproximateBytesUsed_toImage_toImageSyncisRecordingendRecording_endRecording_canvas_kBytesPerShadow	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8ListfromFilePath_initFromFileencodedbytesPerPixelinstantiateCodec_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixel_instantiateCodecmessagestackW_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImageEventCallbackImage_Image
_wrapImageImageDecoderCallback	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizeCallbackTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPictureEventCallbackPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_Callback_CallbackWithError_Callbacker_CallbackerWithError	_futurize_futurizeWithErrorPictureRasterizationExceptiondartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy	withAlphaalpharoundclampintfromRGBOfromARGBmathpowHSVColormaterialColorstransparentCurveselasticInOutAnimationController	_clampInt_lerpInttoIntredgreenblueclampDoubleoverrideObject	identicalruntimeTypehashCodeStringtoRadixStringpadLeftsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopplusmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliaspragmaByteDataListfilledgetInt32_kFakeHostEndiansetInt32indexvaluesfillstroke
getFloat32
setFloat32miterbevel	_TypeNone	_TypeBlur_style_sigmadebugDisposed_validateSamplers	Exception
_debugNamecreator_toNativeColorFilter_toNativeImageFilterfromEnvironmenttoStringStringBufferwritetoStringAsFixed
toByteDataextendedSRGBrawExtendedRgba128
colorSpacevoidwidgets
StackTracecurrent_handlesaddcallMemoryAllocations	_disposedcontainsremoveisEmptydispose
StateErrorformatrawRgbaFuturesRGBUnsupportedErrormaphandle_debugStacktoList__imageNativeFieldWrapperClass1NativeInt32PointerVoidsymbolisLeaf	Uint8Listerrorencodedcallbackbuffer
asByteDataHandleSetwidthheightgetNextFramecloneDurationimage	CompletersyncdecodeErrorcompleteErrorcompletedurationmillisecondsdurationMillisecondsfuturefromUint8ListtargetWidthtargetHeightallowUpscalinggetTargetSizeintrinsicWidthintrinsicHeightinstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPath_clonenonZerozero
fromCircle_opextractPathIterablefromDoublelefttoprightbottomBoolradiusrotationlargeArc	clockwiseFloat32List_getValue32matrix4fromLTRBforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveToIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadowhashcolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashAll
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFiltersigmaXsigmaYtileModeradiusXradiusYMatrix4	diagonal3ArgumentErrordatainnerFilterinnerouterFilteroutermirrorrepeateddecaldilateerodecomposed_shortDescriptionshaderpaintingGradientLinearGradientRadialGradientBoxDecorationlinearradial	Int32ListiNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAngle
isNotEmptyUripath
encodeFull	microtask
_fromAssetMap_initFromAsset	debugNamefragmentShader_uniformFloatCount_samplerCountdrawVertices	trianglestriangleStriptriangleFannew
Uint16ListcolorstextureCoordinatesindicesdrawRawPointsclipRectSceneendRecordingCustomPainterpaintsydoAntiAliasarcTo	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraintspointslinespolygonRSTransformscosssintxtyisRecording_canvascullRectlargestminmax_objects_dataclipOpUint32stack_NativeParagraph_needsLayout_paint
addPicturedrawPicture	onDisposeUint64	_recorderonCreate	TextStylenormaloffset
blurRadiusscalelerp_lerpDoubleshadowIndex_kColorDefaultconvertRadiusToSigma_init_length_initFromFile_initEncodedTttoImageSyncwritelnNativeFieldWrapperClass1CodecEngineLayerPathIterableBaseIteratorImageFilterShaderCanvasPicturePictureRecorderImageDescriptor	Exception‚Ôz n1xˆiVQÁ„A±      	dart:coreÀmÏ ÀR8›| <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu¬­íó@PuœÂÈ‘‘‘\‘i‘‘À‘â’’2’3’ˆ’’³’Ú“ “M“}“ƒ“Æ“Ì””R”ˆ”¾”ô•6•7•e•k•“•™•Á•ç––3–F–G–€–†–Õ–÷—&—'—Z—`—±—Ó—ù—ú˜1˜^˜_˜˜˜Æ˜Ç˜ÿ™,™-™v™¬™²™êšš5š9š:šƒšËšÑ›	›/›]››’›“›ãœœœNœgœ™œœœç#[v¦ª«ü)/g²¶·õŸ2ŸRŸrŸxŸ¹Ÿ½Ÿ¾ 	  c  ‡ Å ã¡#¡^¡›¡×¢¢¢¢<¢B¢Š¢Í¢Ó££j£©£ï£õ¤B¤Œ¤×¥#¥q¥Á¦¦_¦Œ¦’¦á§§6§K§b§w§†§®§¶§Ã§Ú§ü¨¨*¨n¨®¨ò©4©?©G©M©Q©R©•©Û©áª-ªtª¿««Y«™«Á¬ ¬¬¬F¬l¬£¬À¬Î­­^­¦­¯­Ì­ş®,®L®i®{®Æ¯¯b¯k¯q¯u¯v¯Ã¯É¯ô°'°b°f°g°s°–°¸°Ë°Ñ°ı±±±1±R±V±W±c±‰±Š±–±ä±æ±ç²²²k²µ²Ô²Ø³)³v³Å´´c´®´ò´öµFµ‘µâ¶.¶|¶É··[·ª·ğ¸¸¸]¸ª¸ô¹F¹“¹äº%º)ºPºTº¢ºã»4»»Ò¼!¼p¼‹¼¼¼¡¼ì¼ı½½]½p½¶½·½û¾¾=¾C¾ ¾©¾ª¾é¾ï¿>¿M¿S¿¿”¿ï¿ö¿÷À @6À @<À @‡À @˜À @À @àÀ @æÀ AAÀ AHÀ AIÀ A†À AŒÀ AÚÀ B+À BHÀ BNÀ BœÀ BÉÀ BÏÀ C.À C9À C:À CxÀ C~À C§À C­À CûÀ DÀ D`À DfÀ DµÀ DàÀ DëÀ DìÀ E4À EÀ EÎÀ EÜÀ EâÀ F!À F'À FtÀ F¼À FÌÀ FÒÀ GÀ G$À GÀ GŠÀ G‹À GØÀ H&À HpÀ HvÀ H°À H¶À IÀ IUÀ I[À I§À I­À J
À JÀ JÀ JcÀ J¶À KÀ KÀ KKÀ KQÀ KÀ KïÀ KõÀ LBÀ LHÀ L¦À L°À L±À MÀ MSÀ MÀ M£À MŞÀ MäÀ N6À N‚À NˆÀ NÕÀ NÛÀ O9À OCÀ ODÀ O“À O³À O¹À PÀ PÀ P]À P©À PİÀ PãÀ Q.À Q?À QEÀ Q¤À Q¯À Q°À QÿÀ RÀ R À RnÀ RtÀ RÄÀ SÀ S?À SEÀ SÀ S¡À S§À TÀ TÀ TÀ TbÀ T–À TœÀ TéÀ TïÀ UJÀ UQÀ URÀ U‘À U—À UæÀ V2À VXÀ V^À V¬À V²À WÀ WQÀ W¢À WñÀ X;À XAÀ XÀ X¥À X¦À XğÀ XöÀ YEÀ Y”À YšÀ YëÀ ZÀ ZÀ ZkÀ ZqÀ ZÑÀ Z×À ZçÀ ZíÀ [/À [wÀ [“À [İÀ [ôÀ \ À \À \IÀ \JÀ \•À \»À \ÁÀ ]À ]ZÀ ]‰À ]À ]àÀ ^,À ^RÀ ^XÀ ^¨À ^÷À _HÀ _NÀ _À _¿À _ÅÀ `#À `)À `9À `?À `À ` À `èÀ aÀ aNÀ aeÀ aˆÀ a‰À aÒÀ bÀ bÀ bXÀ b¦À b÷À cÀ cÀ chÀ cµÀ cäÀ cêÀ dIÀ dOÀ d_À deÀ dÀ dåÀ e5À e`À ekÀ elÀ eºÀ eÙÀ eßÀ f(À f9À f?À fÀ f§À f¨À f÷À gÀ gÀ geÀ gvÀ g|À gÛÀ gæÀ gçÀ h"À h(À htÀ hÁÀ hğÀ höÀ iXÀ ifÀ igÀ iºÀ iÀÀ jÀ jYÀ jˆÀ jÀ jïÀ jüÀ jıÀ kFÀ kpÀ kvÀ kÆÀ lÀ l]À lŠÀ lÀ lÜÀ m)À mXÀ m^À m¿À mÅÀ mÕÀ mÛÀ nÀ n[À nªÀ nÖÀ nãÀ näÀ o2À oJÀ oPÀ o’À o˜À oùÀ oÿÀ pÀ pÀ pNÀ p[À p\À p¥À p«À púÀ qÀ qÀ q`À qqÀ qwÀ q¯À qµÀ rÀ r%À r&À rrÀ r€À r†À rÕÀ rìÀ ròÀ s;À sLÀ sRÀ sŠÀ sÀ sñÀ sşÀ sÿÀ tMÀ tfÀ tlÀ t»À u
À uÀ u\À u©À uñÀ u÷À vFÀ vjÀ vpÀ vĞÀ vùÀ vúÀ wKÀ wdÀ wjÀ w³À w¹À xÀ xRÀ xxÀ x~À xÙÀ xßÀ xïÀ xõÀ yEÀ ynÀ y½À yîÀ yõÀ yöÀ zGÀ z`À zfÀ z¯À zÿÀ {,À {2À {À {“À {£À {©À {ëÀ |:À |PÀ |^À |_À |°À |ÉÀ |ÏÀ }À }À }gÀ }·À }ìÀ }òÀ ~OÀ ~UÀ ~eÀ ~kÀ ~¡À ~ïÀ =À FÀ GÀ ˜À ±À ·À € À €PÀ €}À €ƒÀ €åÀ €ëÀ €ûÀ À PÀ fÀ ±À ÊÀ ØÀ ÚÀ ÛÀ ‚3À ‚nÀ ‚rÀ ‚ÏÀ ƒÀ ƒÀ ƒoÀ ƒÃÀ „À „mÀ „qÀ „¿À „úÀ „şÀ …WÀ …[À …¨À …ğÀ †À †À †!À †%À †pÀ †©À †¿À †ÜÀ †÷À ‡À ‡5À ‡PÀ ‡eÀ ‡»À ‡ãÀ ‡äÀ ˆ(À ˆ.À ˆtÀ ˆ¹À ˆÁÀ ˆÂÀ ˆúÀ ‰ À ‰BÀ ‰qÀ ‰xÀ ‰yÀ ‰ÃÀ ‰ëÀ ‰ñÀ Š<À Š‰À ŠÒÀ ‹À ‹#À ‹SÀ ‹cÀ ‹iÀ ‹¸À ‹ìÀ ŒÀ ŒÀ ŒÀ Œ\À ŒiÀ ŒoÀ Œ½À ŒúÀ  À 'À -À À ÏÀ À  À MÀ UÀ WÀ XÀ |À €À À ’À ÇÀ 
À FÀ WÀ —À À îÀ RÀ XÀ ¦À ØÀ àÀ áÀ ‘À ‘"À ‘lÀ ‘¼À ’,À ’2À ’‚À ’§À ’°À ’±À ’ôÀ “9À “^À “dÀ “³À ”$À ”*À ”zÀ ”ŸÀ ”¥À ”óÀ •À •À •À • À •JÀ •NÀ •›À •ßÀ •ãÀ •ñÀ •õÀ –AÀ –MÀ –ˆÀ –ÅÀ –×À —À —À —|À —‚À —ÊÀ ˜À ˜&À ˜,À ˜<À ˜BÀ ˜À ˜¡À ˜òÀ ™+À ™4À ™5À ™jÀ ™pÀ ™×À ™İÀ š%À šuÀ šÀ š‡À š—À šÀ šëÀ šüÀ ›À ›À ›TÀ ›†À ›ŒÀ ›óÀ ›ùÀ œAÀ œ‘À œÀ œ£À œ³À œ¹À À À !À #À $À ^À bÀ yÀ µÀ ÊÀ À #À $À jÀ °À ×À ßÀ àÀ Ÿ$À ŸjÀ Ÿ±À ŸïÀ ŸùÀ ŸûÀ ŸüÀ  +À  7À  MÀ  SÀ  À  ïÀ  õÀ ¡AÀ ¡WÀ ¡¤À ¡ıÀ ¢RÀ ¢kÀ ¢sÀ ¢tÀ ¢ À ¢¦À ¢ÿÀ £0À £6À £vÀ £|À £ÔÀ ¤/À ¤5À ¤EÀ ¤KÀ ¤§À ¤ËÀ ¤×À ¤ØÀ ¤÷À ¤ıÀ ¥IÀ ¥OÀ ¥¢À ¥¨À ¥ïÀ ¥õÀ ¦JÀ ¦iÀ ¦ÀÀ ¦ÆÀ ¦ÖÀ ¦ÜÀ §$À §oÀ § À §ıÀ ¨
À ¨À ¨WÀ ¨]À ¨°À ©À ©+À ©1À ©ƒÀ ©ĞÀ ª"À ªtÀ ªzÀ ªÊÀ «À «hÀ «¸À «şÀ ¬À ¬À ¬À ¬hÀ ¬‚À ¬„À ¬…À ¬ÇÀ ¬ËÀ ­À ­0À ­DÀ ­ŒÀ ­¢À ­­À ­®À ­İÀ ­âÀ ®-À ®xÀ ®ÇÀ ¯À ¯dÀ ¯iÀ ¯¹À °
À °À ° À °hÀ °iÀ °ŠÀ °¦À °ÚÀ °ÛÀ ±À ±+À ±TÀ ±yÀ ±¤À ±ÍÀ ±÷À ²'À ²TÀ ²~À ²²À ²âÀ ³À ³À ³QÀ ³‡À ³ÅÀ ³ûÀ ´=À ´{À ´»À µÀ µMÀ µÀ µßÀ ¶)À ¶kÀ ¶lÀ ¶­À ¶ïÀ ¶ğÀ ·4À ·UÀ ·qÀ ·ŒÀ ·À ·»À ·şÀ ¸À ¸À ¸)À ¸TÀ ¸À ¸ÓÀ ¸ÔÀ ¹À ¹(À ¹.À ¹FÀ ¹_À ¹¦À ¹ªÀ ¹ÊÀ ºÀ ºDÀ ºkÀ º¯À º³À º´À ºìÀ »À »À »VÀ »\À »|À »‚À »’À »˜À »ŞÀ ¼À ¼WÀ ¼]À ¼¥À ¼ºÀ ¼ÎÀ ½À ½CÀ ½GÀ ½bÀ ½˜À ½ÖÀ ½ÚÀ ½ÛÀ ¾À ¾TÀ ¾UÀ ¾¡À ¾§À ¾éÀ ¿:À ¿‹À ¿¬À ¿²À ¿ÿÀ À À À&À ÀMÀ ÀSÀ ÀcÀ ÀiÀ À¸À ÀìÀ Á6À ÁLÀ ÁhÀ ÁµÀ ÁğÀ ÁôÀ ÂÀ ÂQÀ Â“À Â—À Â˜À ÂÜÀ ÂâÀ Ã
À Ã&À ÃxÀ Ã|À ÃŸÀ ÃÄÀ ÄÀ ÄÀ ÄÀ ÄAÀ ÄÀ ÄÍÀ ÄÓÀ ÅÀ Å+À ÅoÀ ÅsÀ Å•À Å·À ÅıÀ ÆÀ ÆÀ ÆCÀ ÆsÀ ÆyÀ Æ«À ÆÇÀ ÇÀ ÇÀ Ç@À ÇeÀ Ç§À Ç«À Ç¬À ÇíÀ ÇóÀ ÈDÀ ÈÀ È•À ÈÏÀ ÈÕÀ ÈóÀ ÈùÀ ÉbÀ ÉhÀ ÉÏÀ ÉÕÀ Ê<À ÊBÀ ÊÀ ÊßÀ ÊëÀ ÊñÀ ËÀ ËÀ ËVÀ Ë‚À ËËÀ Ì
À Ì(À Ì|À Ì€À Ì¥À ÌÊÀ ÍÀ ÍÀ ÍÀ ÍJÀ ÍÀ Í‚À ÍÍÀ ÎÀ ÎfÀ Î³À ÏÀ ÏÀ ÏLÀ ÏRÀ Ï À ÏÄÀ ÏÊÀ Ğ3À Ğ9À Ğ¢À Ğ¨À ÑÀ ÑÀ ÑcÀ Ñ´À ÑÀÀ ÑÆÀ ÑÖÀ ÑÜÀ Ò&À ÒAÀ ÒŠÀ ÒªÀ ÒóÀ Ò÷À ÓÀ Ó\À Ó§À Ó«À Ó¬À ÓüÀ Ô:À Ô@À ÔdÀ ÔƒÀ ÔÇÀ ÔèÀ ÔıÀ ÕÀ Õ>À Õ™À ÕàÀ ÕëÀ ÕñÀ ÖÀ ÖÀ Ö,À ÖEÀ Ö—À ÖßÀ ×'À ×4À ×À ×³À ØÀ Ø^À Ø¯À ØµÀ Ø¹À ØºÀ ÙÀ Ù`À Ù¬À Ù²À ÙÚÀ Ú'À ÚKÀ Ú¥À Ú©À ÚÔÀ ÚùÀ Û?À ÛCÀ ÛDÀ Û~À Û„À ÛºÀ ÛÀÀ ÛĞÀ ÛÖÀ ÜÀ ÜJÀ Ü|À ÜÄÀ ÜÛÀ İÀ İÀ İ-À İ=À İKÀ İzÀ İ±À İºÀ İÍÀ İ×À İçÀ ŞÀ Ş6À Ş–À Ş À Ş¨À Ş»À ŞÅÀ ŞıÀ ßÀ ßÀ ßIÀ ß[À ßaÀ ß†À ßŒÀ ßİÀ ßşÀ àUÀ àwÀ à{À à£À àéÀ á	À á'À áUÀ á]À ájÀ á°À á¶À áºÀ á»À áöÀ áüÀ âCÀ â]À âcÀ âqÀ âÀ â¸À âÊÀ âäÀ ã4À ã?À ãGÀ ãQÀ ãWÀ ãgÀ ãmÀ ã¨À ãÉÀ ä À äBÀ äFÀ änÀ ä‡À ä¥À äÓÀ äÛÀ äèÀ å)À åÀ åªÀ åîÀ åöÀ åüÀ æ À æÀ æ@À æFÀ æ’À æÜÀ çÀ ç'À çnÀ çrÀ ç“À çİÀ çáÀ çâÀ çîÀ èÀ è=À è\À èbÀ è’À è­À èÉÀ èòÀ éÀ é0À élÀ é{À éÀ é¦À éÏÀ éôÀ éüÀ ê(À êeÀ êºÀ êÄÀ êÓÀ êùÀ ëÀ ëÀ ëÀ ë7À ëhÀ ë€À ë†À ë¶À ëŞÀ ëöÀ ëüÀ ì-À ìYÀ ìqÀ ìwÀ ì–À ìÓÀ ìëÀ ìñÀ íÀ íJÀ íbÀ íhÀ í—À íØÀ íğÀ íöÀ îÀ îCÀ î[À îaÀ î€À î½À îÕÀ îÛÀ îóÀ ï,À ï2À ïIÀ ïgÀ ïkÀ ïmÀ ïnÀ ï¹À ï½À ğ À ğJÀ ğ•À ğÇÀ ğËÀ ğşÀ ñÀ ñ:À ñLÀ ñhÀ ñnÀ ñ»À ñçÀ ñíÀ ò À ò(À òuÀ òÃÀ òûÀ ó4À óDÀ óFÀ óGÀ ó‰À ó¡À óïÀ ô<À ô„À ôÎÀ ôåÀ ôüÀ õÀ õ`À õkÀ õlÀ õŒÀ õ’À õëÀ õşÀ õÿÀ öÀ ö"À örÀ ö­À ö¾À ö¿À öåÀ öëÀ ÷7À ÷dÀ ÷jÀ ÷À ÷…À ÷“À ÷±À ÷ÑÀ ÷×À øÀ ø=À ø“À øÕÀ øöÀ ùÀ ù*À ùDÀ ù^À ùiÀ ùqÀ ù{À ù‘À ù’À ù¤À ùªÀ ùúÀ úHÀ ú”À úáÀ û*À û0À ûÀ ûÀ û“À û£À û©À üÀ üMÀ üTÀ üVÀ üWÀ ü–À ü©À ü÷À ıGÀ ızÀ ı†À ı‡À ıÖÀ ş%À şXÀ şdÀ şeÀ şµÀ şüÀ ÿKÀ ÿ†À ÿ•À ÿ—À ÿ˜À ÿÄÀ ÿıÀ ÿşÀ 4À 8À xÀ |À ÊÀ âÀ æÀ5À„ÀËÀÀaÀoÀsÀ¿ÀÀUÀYÀgÀkÀÙÀ(ÀNÀÀ«ÀİÀíÀÀ(À2ÀQÀkÀoÀpÀ‘À­ÀÄÀÅÀÀ	ÀTÀ–À·ÀŞÀßÀÀ$ÀoÀ²ÀÓÀûÀüÀÀÀ\ÀoÀpÀ²ÀÆÀÇÀáÀ	.À	_À	eÀ	¶À	ÑÀ	×À
"À
mÀ
¼À
ÜÀ
ïÀ
À7ÀcÀyÀ°ÀÅÀèÀ ÀÀ
ÀÀOÀUÀ£À¹ÀÔÀèÀøÀÀ'À1ÀŸÀ£À¤ÀÙÀßÀ+À;ÀAÀ†ÀÕÀÀ"ÀoÀˆÀØÀ'ÀqÀ½ÀÀ?ÀmÀqÀrÀ®À´À ÀOÀ{ÀÀĞÀÀQÀÀÊÀèÀÀ:ÀHÀhÀvÀÀ­ÀûÀÀÀÀWÀyÀÀ¿ÀõÀÀ#ÀwÀŠÀ”À§À«À¬ÀİÀãÀ2ÀÀÒÀÀjÀ¸ÀÀ"À(ÀvÀŸÀ¥ÀíÀ>ÀTÀZÀÀ–À¤À¿ÀßÀ÷ÀıÀ5ÀtÀ“ÀİÀîÀ À ÀpÀ¾ÀäÀÀ%ÀFÀNÀTÀvÀªÀõÀ ÀcÀ§ÀäÀıÀÀ?ÀoÀuÀ’À¬À²ÀÔÀòÀ À À À 7À ZÀ `À {À À ¤À İÀ çÀ íÀ!À! À!*À!0À!uÀ!ÃÀ!çÀ!ùÀ"À"&À"QÀ"¢À"ğÀ#2À#;À#AÀ#`À#‹À#À#À#ÜÀ$"À$(À$uÀ$¿À%À%^À%¨À%õÀ&.À&/À&;À&eÀ&gÀ&hÀ&‚À&·À' À'À' À'nÀ'À'¬À'ºÀ'»À(
À($À(%À(uÀ(À(‘À(æÀ)/À)|À)¬À)ãÀ)ôÀ*À*À*)À*1À*5À*6À*rÀ*ÈÀ+!À+"À+<À+OÀ+gÀ+sÀ+‹À+ØÀ+ğÀ,:À,rÀ,yÀ,À,ŸÀ,£À,¤À,ïÀ-À-VÀ-rÀ-sÀ-œÀ-À-ãÀ.À.À.À.?À.AÀ.BÀ.\À.}À.±À.³À.´À.æÀ/"À/#À/WÀ/[À/—À/±À/µÀ/ÿÀ0HÀ0–À0ÜÀ1'À1PÀ1TÀ1À1‘À1À1©À1ãÀ2$À2BÀ2À2ÚÀ2÷À3CÀ3bÀ3ƒÀ3‰À3‘À3•À3«À3¯À3»À3ÈÀ4À4CÀ4ƒÀ4ÂÀ5À5(À5wÀ5¿À5àÀ5æÀ5îÀ6 À6JÀ6fÀ6lÀ6ªÀ6ÆÀ7À7À74À7:À7‡À7¢À7£À7ÌÀ7ÒÀ8À8 À8lÀ8À8ƒÀ8„À8¤À8¨À8ğÀ9
À9À9FÀ9cÀ9zÀ9 À9¶À9·À9æÀ9ìÀ: À:EÀ:`À:aÀ:‰À:À:ÓÀ:ÙÀ;*À;0À;qÀ;¡À;ÅÀ;ÆÀ<À<9À<?À<ŠÀ<¯À<ÁÀ<ÃÀ<ÄÀ=À=À=^À=yÀ=~À=·À=ÕÀ=éÀ=êÀ>À>À>À>LÀ>MÀ>¡À>ÁÀ>ÂÀ>áÀ>âÀ>îÀ?8À?9À?’À?·À?¸À?ÄÀ?ïÀ@7À@ŸÀ@ºÀ@İÀA>ÀAHÀAÀAÀA¸ÀAôÀB6ÀBBÀBJÀBRÀBkÀB‰ÀBÀB¬ÀB°ÀB±ÀBíÀC>ÀCÀCÀC›ÀCİÀCøÀCùÀDÀDfÀDhÀDiÀDŒÀDÀDßÀE/ÀE}ÀE ÀE¤ÀEöÀFDÀF_ÀFŸÀFÄÀGÀG[ÀG§ÀG÷ÀH
ÀHÀHYÀH£ÀHóÀIBÀIÀIßÀJ.ÀJvÀJ²ÀJ¶ÀK ÀKJÀKšÀKÖÀKÚÀL'ÀL3ÀLXÀLlÀL€ÀL•ÀL³ÀL¾ÀM
ÀM4ÀM@ÀM^ÀM~ÀM¢ÀM§ÀM©ÀMªÀMÍÀMÑÀN ÀNpÀN¾ÀNáÀNåÀO9ÀO‡ÀOÀÀOÄÀPÀPfÀPrÀPvÀPÁÀQÀQ[ÀQªÀQöÀRGÀR–ÀRŞÀSÀSÀShÀS²ÀTÀT>ÀTBÀTÀT›ÀTŸÀTÄÀTÈÀUÀUcÀU®ÀUÖÀVÀV!ÀV5ÀVJÀVhÀVmÀV•ÀV¡ÀVàÀVıÀWAÀWiÀWsÀWºÀWäÀWîÀWöÀX>ÀXEÀXJÀXLÀXMÀXpÀXtÀX¿ÀXÃÀYÀY_ÀYÀY¢ÀYëÀZ:ÀZPÀZTÀZ¢ÀZïÀ[;À[|À[ËÀ\À\kÀ\»À\òÀ\öÀ]@À]ŠÀ]¾À]ÂÀ^À^À^À^DÀ^HÀ^˜À^ãÀ_.À_VÀ_ƒÀ_ŸÀ_ÉÀ_ÔÀ_şÀ`JÀ`RÀ`­À`ìÀa-ÀaUÀazÀa¡Àa¨Àa¶ÀaÌÀaĞÀaÒÀaÓÀb#ÀbEÀbGÀbHÀb—ÀbÀÀbÄÀbÒÀbÖÀc ÀcAÀc}Àc“ÀcªÀc­Àc®ÀcóÀc÷ÀdÀd	ÀdUÀd“Àd»ÀdÓÀdÿÀeÀeTÀelÀeŸÀeËÀeùÀeúÀf(Àf.Àf}ÀfÍÀgÀghÀg“Àg™ÀgÏÀgãÀgäÀhÀhÀhiÀh¸ÀiÀiSÀi}ÀiƒÀi¹ÀiÎÀiÏÀiÛÀjÀjÀjÀjcÀjgÀj¶ÀkÀkKÀk•ÀkÂÀkÄÀkÅÀl#Àl\Àl–Àl³ÀlµÀl¶ÀlóÀl÷ÀmEÀmÀm¨Àm¬ÀmøÀnIÀnˆÀnŒÀn×Ào!ÀoqÀoÀÀpÀp]Àp¬ÀpôÀq0Àq4Àq~ÀqÈÀrÀrTÀrpÀr„Àr‘ÀrŸÀrµÀrØÀréÀrıÀsÀs0Às5ÀsRÀs†ÀsŠÀs¨ÀsŞÀsâÀsãÀtÀt0ÀtnÀt~Àt”Àt¬ÀtÈÀtåÀtîÀtïÀuÀuRÀu|Àu†ÀuÏÀuûÀvÀvÀvÀvÀv:Àv^Àv„ÀvÀv¬ÀvğÀwÀw'Àw2ÀwXÀwtÀw”Àw•ÀwÁÀwÍÀwÓÀwÕÀwÖÀx#Àx3Àx7ÀxnÀx‚ÀxÌÀxÒÀy#ÀyrÀyÁÀyìÀyòÀz*Àz5Àz6ÀzxÀz~ÀzÏÀ{ À{&À{_À{jÀ{lÀ{mÀ{‘À{•À{£À{§À{öÀ|À|1À|eÀ|kÀ|¹À}À}EÀ}KÀ}[À}aÀ}°À}ÊÀ}ØÀ~'À~MÀ~SÀ~¡À~ïÀ	ÀÀÀVÀcÀ®À´À€À€MÀ€‚À€‹À€ÖÀÀÀcÀ·À½ÀÍÀ‚
À‚À‚EÀ‚KÀ‚™À‚äÀƒ%Àƒ+Àƒ;ÀƒAÀƒŠÀƒ£Àƒ¸ÀƒºÀƒ»À„À„)À„yÀ„œÀ„¢À„òÀ…;À…ŒÀ…ÕÀ…ïÀ…õÀ†DÀ†À†ÊÀ†ĞÀ‡À‡@À‡RÀ‡TÀ‡UÀ‡­À‡÷ÀˆÀˆ-Àˆ.Àˆ:Àˆ‚ÀˆÀˆŸÀˆ ÀˆÒÀˆÖÀ‰À‰À‰bÀ‰¡À‰µÀ‰¹À‰ÿÀŠ*ÀŠ.ÀŠmÀŠ°ÀŠØÀŠÜÀ‹ À‹YÀ‹oÀ‹À‹À‹¸À‹¾ÀŒÀŒZÀŒ}ÀŒ±ÀŒáÀŒøÀŒüÀŒıÀ;ÀAÀ†À£ÀÇÀÈÀıÀ À!ÀiÀ–À—ÀŞÀëÀÀÀVÀˆÀµÀ¶ÀùÀ9ÀHÀNÀ¿À‘4À‘zÀ‘{À‘¾À’À’JÀ’WÀ’¥À’¦À’ëÀ“2À“AÀ“GÀ“´À”%À”wÀ”xÀ”½À•À•IÀ•^À•¸À•¹À•ÿÀ–CÀ–ˆÀ–ÏÀ–ôÀ–úÀ—gÀ—ØÀ˜À˜À˜eÀ˜©À˜îÀ™5À™{À™£À™ñÀ™òÀš5ÀšWÀš]Àš ÀšÄÀšÊÀ›À›QÀ›˜À›ÜÀœ#ÀœgÀœ•Àœ›ÀœàÀÀgÀhÀ·ÀüÀÀQÀšÀŞÀŸÀŸÀŸPÀŸŸÀŸëÀŸñÀ À 5À PÀ kÀ †À ŒÀ À ÜÀ¡!À¡'À¡[À¡aÀ¡°À¡şÀ¢AÀ¢‹À¢‘À¢ÔÀ£"À£oÀ£†À£¡À£»À£ÜÀ£÷À¤À¤-À¤3À¤4À¤{À¤’À¤­À¤®À¤ğÀ¥À¥$À¥vÀ¥ÄÀ¥ßÀ¥àÀ¦(À¦eÀ¦¤À¦åÀ§+À§oÀ§³À§¿À§ÅÀ¨1À¨¡À¨§À©À©‹À©ËÀ©ÌÀªÀª,Àª2ÀªÀª¦Àª¬ÀªóÀ«'À«(À«jÀ«­À«½À«ÛÀ«ÜÀ¬"À¬(À¬uÀ¬ÃÀ¬îÀ­0À­1À­wÀ­¶À­óÀ­ùÀ®FÀ®—À®ÂÀ¯À¯À¯QÀ¯’À¯¢À¯£À¯èÀ°,À°GÀ°WÀ°XÀ°¨À°õÀ±À±À±bÀ±hÀ±­À±ÌÀ±ÍÀ²À²<À²YÀ²ZÀ²šÀ²ÊÀ²ñÀ²òÀ³'À³-À³}À³ÊÀ´À´TÀ´ZÀ´«À´úÀµLÀµ™ÀµãÀ¶1À¶?À¶„À¶˜À¶™À¶åÀ¶øÀ¶şÀ·NÀ·œÀ·ÖÀ¸À¸KÀ¸œÀ¸¯À¸µÀ¹,À¹0À¹1À¹€À¹±À¹·ÀºÀºKÀºšÀºéÀ»3À»kÀ»qÀ»¼À¼	À¼RÀ¼†À¼ŒÀ¼ÜÀ½)À½yÀ½¼À¾	À¾VÀ¾¥À¾õÀ¿DÀ¿JÀ¿˜À¿çÀÀÀÀ!ÀÀrÀÀ½ÀÀ÷ÀÀùÀÀúÀÁDÀÁlÀÁÀÁ‘ÀÁßÀÂ$ÀÂ7ÀÂ8ÀÂqÀÂ‘ÀÂ’ÀÂÙÀÂÿÀÃ ÀÃÀÃPÀÃ\ÀÃÀÃÀÃòÀÄÀÄÀÄlÀÄ˜ÀÄ™ÀÄ¥ÀÅÀÅ/ÀÅ0ÀÅ<ÀÅ¢ÀÅØÀÅÙÀÅåÀÆCÀÆoÀÆpÀÆ|ÀÆâÀÇÀÇÀÇ%ÀÇÀÇíÀÇîÀÇúÀÈ{ÀÈ¦ÀÈÙÀÈÚÀÈæÀÉeÀÉÀÀÉÁÀÉÍÀÊTÀÊ·ÀÊ¸ÀÊÄÀË;ÀËŠÀË‹ÀË—ÀÌÀÌmÀÌnÀÌzÀÌÌÀÌìÀÍKÀÍOÀÍPÀÍÓÀÎYÀÎZÀÎfÀÎ‰ÀÎªÀÎÅÀÎàÀÎûÀÏÀÏ&ÀÏJÀÏ¤ÀÏ¨ÀÏ©ÀĞ/ÀĞ¼ÀĞ½ÀĞÉÀĞäÀĞşÀÑÀÑ:ÀÑUÀÑpÀÑwÀÑ ÀÑÄÀÒ0ÀÒ4ÀÒ5ÀÒÃÀÒèÀÒşÀÓÀÓ*ÀÓ@ÀÓWÀÓlÀÓƒÀÓ„ÀÓÀÓ¬ÀÓÌÀÔÀÔÀÔÀÔ|ÀÔÌÀÔÍÀÔÙÀÔõÀÕÀÕQÀÕUÀÕVÀÕÅÀÖÀÖÀÖ"ÀÖcÀÖƒÀÖÖÀÖÚÀÖÛÀ×YÀ×ÎÀ×ÏÀ×ÛÀØÀØBÀØFÀØGÀØ™ÀØÖÀØ×ÀØãÀÙÀÙ$ÀÙHÀÙLÀÙMÀÙ—ÀÙÅÀÙÆÀÙÒÀÚÀÚ9ÀÚTÀÚ|ÀÚÊÀÚ×ÀÛÀÛÀÛÀÛÀÛ}ÀÛ¿ÀÛÀÀÜ2ÀÜ’ÀÜ“ÀÜŸÀÜéÀİÀİ(ÀİPÀİ¤Àİ±ÀİóÀİùÀİıÀİşÀŞeÀŞ®ÀŞ¯Àß'ÀßÀßÀßšÀßçÀà ÀàÀàÀàZÀàsÀàtÀà€Àà ÀàÃÀàíÀàñÀàòÀáRÀáÀá‚ÀáÀá¬ÀáĞÀáşÀâ&Àâ7Àâ;Àâ<Àâ“ÀâÏÀâĞÀâÜÀãÀã*ÀãXÀãwÀãˆÀãŒÀãÀãàÀäÀä Àä,ÀäAÀälÀäªÀä®Àä¯ÀäôÀåÀåÀå{ÀåÅÀåÆÀåÒÀæÀæ:Àæ>Àæ?ÀæKÀæjÀælÀæmÀæ¯Àæ³ÀæÁÀçÀç/Àç`ÀçfÀçŒÀç¹ÀçºÀçÿÀèÀèZÀè†ÀèÃÀéÀéÀéÀé/Àé5ÀéˆÀéÌÀéåÀéæÀêÀêÀêjÀê¼ÀêØÀêïÀêğÀë Àë&ÀëvÀëÅÀëáÀëçÀì5Àì„ÀìÓÀí!Àí2ÀíwÀí°Àí²Àí³ÀíûÀíÿÀîPÀîœÀîâÀîæÀï,Àï0Àï|ÀïËÀïéÀïíÀğ7Àğ‡Àğ¨ÀğèÀñÀñmÀñnÀñ–Àñ—Àñ£ÀñÕÀñ×ÀñØÀò'ÀòAÀò|Àò§Àò¨ÀòÃÀòæÀòçÀòóÀóÀóAÀóbÀózÀóİÀô9Àô­Àô¶Àô¼ÀôÖÀôÚÀôÛÀôçÀôûÀõ"ÀõRÀõeÀõkÀõƒÀõ•Àõ™Àõ›ÀõœÀõÛÀõßÀö'ÀörÀöÀÀöäÀöèÀ÷6À÷…À÷ÑÀø!ÀøoÀø}ÀøÀø®ÀøìÀù.ÀùaÀùbÀù˜ÀùÀùçÀú1ÀúzÀú‘Àú’Àú·Àú½ÀûÀûQÀû¡ÀûÀÀû×ÀûØÀüÀü	ÀüYÀü ÀüîÀı=ÀıvÀı|ÀıÊÀşÀşiÀş¢Àş¼Àş½ÀşÜÀşİÀÿ-ÀÿTÀÿZÀÿ©ÀÿöÀ À À IÀ OÀ •À ÇÀÀÀÀVÀ\ÀÀâÀ0ÀÀ‘À’ÀÀÀÀ	ÀDÀyÀÀ¢À£ÀøÀ:À;À_ÀÕÀ÷ÀûÀüÀ]ÀŠÀ‹ÀÏÀÿÀMÀÀËÀçÀúÀÀÀCÀhÀqÀwÀ{À|À×ÀÀÀ]À„ÀúÀ	(À	kÀ	|À	€À	À	ñÀ
_À
`À
„À
úÀÀ"À#ÀÀ®À¯ÀÚÀßÀ4À^ÀvÀ¢À²ÀÏÀÕÀæÀêÀëÀEÀkÀlÀ¸À¾ÀÿÀÀ!À"ÀWÀ“À¤ÀÜÀİÀ*ÀmÀwÀxÀÆÀÀ@ÀIÀJÀ—ÀèÀ+À4À5À…À“ÀœÀÀŸÀìÀ<ÀNÀRÀ£À¶ÀÀÀ;ÀAÀ’À˜ÀçÀ5À…À–ÀœÀëÀñÀÀÀ-À3À€À™ÀªÀ»ÀÀÀÁÀÛÀòÀóÀ9À„À®ÀäÀåÀñÀÀ3ÀUÀxÀ|À}À‰À¼À½ÀÉÀÀÀÀnÀ½ÀÀWÀˆÀŒÀÕÀâÀÀZÀ«ÀïÀõÀFÀ”ÀÁÀüÀÀ4ÀLÀhÀiÀ³ÀúÀÀÀbÀŠÀÀÃÀöÀ)À\ÀÀ•ÀäÀ0À6ÀDÀ„À›À²ÀÉÀàÀêÀôÀúÀ À À 3À 9À GÀ …À ¡À ½À ÙÀ õÀ ÿÀ!	À!À!–À!œÀ!ªÀ!çÀ"
À"-À"PÀ"sÀ"}À"‡À"À#À#À#*À#kÀ#‘À#·À#İÀ$À$À$À$GÀ$^À$yÀ$“À$±À$²À$şÀ%À%6À%MÀ%hÀ%€À%©À%ªÀ%øÀ&À&;À&RÀ&mÀ&…À&®À&¯À&ÆÀ&åÀ'À'À'À'HÀ'}À'ÁÀ(
À(SÀ(TÀ(lÀ(xÀ(ÅÀ(ÆÀ(ïÀ)À)À)OÀ)fÀ)pÀ)˜À)±À)ßÀ)ıÀ*À*À*iÀ*“À*·À*ìÀ+À+EÀ+TÀ+–À+œÀ+ À+¡À+­À+ĞÀ+üÀ,À,À,6À,VÀ,À,¯À,ÚÀ,ŞÀ,ßÀ,ëÀ- À-*À-À-‘À-’À-À-¿À-ÔÀ-ëÀ.$À.=À.lÀ.À.ÂÀ.æÀ/À/'À/LÀ/RÀ/VÀ/WÀ/cÀ/yÀ/À/¥À/ŞÀ/÷À0&À0JÀ0|À0 À0ÒÀ0áÀ1}À1ƒÀ1‡À1‰À1ŠÀ1ÈÀ1ÌÀ2À2gÀ2¹À2ÏÀ3
À3,À3dÀ3xÀ3¹À3½À3¾À3âÀ4À40À4iÀ4mÀ4œÀ4áÀ4õÀ5À5À5À5GÀ5ŒÀ5 À5¾À5ÂÀ5ÃÀ6À67À6TÀ6UÀ6•À6µÀ6¶À7À7PÀ7QÀ7¤À7ÕÀ7ÖÀ8:À8dÀ8eÀ8ÉÀ8óÀ8õÀ8öÀ9)À9-À9;À9?À9À9ÛÀ:*À:RÀ:À:ÉÀ:æÀ;8À;eÀ;fÀ;¢À<À<jÀ<nÀ<oÀ<¼À=À=QÀ=”À=˜À=™À=İÀ>/À>}À>¿À>ÃÀ>ÄÀ?À?À?\À?¦À?ØÀ@$À@DÀ@‚À@ˆÀ@êÀ@îÀ@ïÀA9ÀA?ÀAÀAÅÀAêÀBFÀBÀB’ÀB“ÀBäÀC1ÀCXÀCYÀC¢ÀCÚÀCúÀCüÀCıÀD/ÀDzÀD{ÀD•ÀDºÀD»ÀDÜÀE ÀE,ÀEcÀEdÀEpÀE³ÀE´ÀEÀÀFÀFÀFÀF4ÀF`ÀFtÀFzÀF¡ÀFÑÀGÀGÀGÀGÀG\ÀG^ÀG_ÀG—ÀGûÀGüÀHÀH*ÀHEÀHFÀHZÀHœÀH¨ÀHßÀHàÀHûÀIÀI>ÀIkÀIœÀIÇÀIÍÀIÑÀIÒÀIŞÀJ(ÀJ)ÀJ5ÀJ€ÀJÀJÀJ°ÀJÜÀJğÀJöÀK#ÀKEÀKgÀKÀK’ÀK“ÀKŸÀKÒÀKÔÀKÕÀLÀLOÀLPÀLhÀL€ÀLÀLÅÀLÑÀMÀM	ÀMÀMUÀMVÀMbÀM£ÀM¤ÀM°ÀMÓÀMÿÀNÀNÀN@ÀNdÀN‰ÀNÀNÀNšÀNÏÀNÑÀNÒÀOÀOJÀOKÀOcÀO{ÀO|ÀO¿ÀOËÀPÀPÀPÀPNÀPOÀP[ÀP›ÀPœÀP¨ÀPËÀP÷ÀQÀQÀQ7ÀQ[ÀQ€ÀQ„ÀQ…ÀQ‘ÀQÆÀQÈÀQÉÀQüÀRMÀRNÀRoÀRÀR‘ÀR«ÀRñÀRıÀS4ÀS5ÀSAÀS«ÀS¬ÀS¸ÀTÀTÀTÀT>ÀTjÀT~ÀT„ÀT¬ÀTØÀUÀU	ÀU
ÀUÀUSÀUUÀUVÀU•ÀU™ÀUéÀV<ÀV€ÀV»ÀV÷ÀW,ÀWEÀWYÀWÀW¡ÀW¢ÀWïÀX5ÀXfÀXÀX“ÀXÄÀXÈÀXÉÀYÀY_ÀYÀY§ÀY»ÀYëÀYïÀYğÀZ4ÀZ:ÀZˆÀZÒÀ[À[À[@À[~À[„À[˜À[ÒÀ[ÖÀ[×À\	À\<À\UÀ\iÀ\¯À\ÓÀ\×À\ØÀ]À]?À]XÀ]lÀ]ÂÀ^À^QÀ^UÀ^VÀ^–À^¶À^·À_%À_lÀ_mÀ_ÖÀ`À`À`|À`¸À`¹ÀaÀaXÀaYÀa¸ÀaõÀaöÀbfÀb¹ÀbºÀcÀc.ÀcKÀcMÀcNÀc”ÀcÉÀcşÀdHÀddÀd€ÀdÀdÀd®Àd¯ÀdØÀdŞÀe/ÀeJÀebÀerÀe“Àe¦Àe°ÀeÅÀeÉÀeÊÀfÀf=ÀfCÀfÀfÚÀg#ÀgmÀgsÀg¸ÀgËÀgÛÀgúÀhÀh*Àh4Àh8Àh:Àh;ÀhÀh©Àh­ÀhúÀiHÀi•ÀiåÀiéÀj>Àj’ÀjëÀkCÀk–Àk¿ÀkÃÀlÀlBÀlFÀlTÀlXÀlœÀlæÀm6Àm`ÀmªÀmòÀnÀnfÀn´ÀnÎÀo	ÀoÀosÀoyÀoÅÀpÀpÀpiÀp‰ÀpÀpòÀqUÀq·ÀqÀÀqÁÀrÀrÀrpÀrÎÀrúÀs ÀsZÀs·Às½Àt#Àt‰ÀtîÀtúÀtûÀuNÀuTÀu¬ÀvÀvZÀvuÀv{ÀvÕÀw+Àw@ÀwFÀwªÀxÀxqÀx{Àx|Àx¼ÀxÂÀyÀywÀy‡ÀyÀyæÀzÀzÀzoÀzÒÀ{4À{=À{?À{@À{qÀ{™À{ËÀ{ôÀ|À|À|*À|,À|-À|aÀ|‰À|ÃÀ|ìÀ}
À}-À}QÀ}tÀ}“À}²À}¶À}ÇÀ}ÉÀ}ÊÀ~À~)À~KÀ~xÀ~‘À~ªÀ~ÃÀ~ÜÀ~íÀ~ïÀ~ğÀ8À<ÀÀ¡À¥À³À·À€-À€1À€VÀ€‹À€‘À€àÀ1À{ÀÊÀ‚À‚lÀ‚¼À‚ŞÀ‚äÀƒ3ÀƒiÀƒoÀƒÒÀ„5À„™À„ÿÀ…À…PÀ…–À…±À…·À†À†WÀ†—À†ªÀ†»À†ÊÀ†äÀ‡À‡*À‡DÀ‡iÀ‡ŒÀ‡ÈÀ‡ÛÀˆÀˆLÀˆ‰ÀˆñÀ‰À‰`À‰dÀ‰eÀ‰°À‰ĞÀ‰ÖÀŠ%ÀŠvÀŠÀÀ‹À‹`À‹±ÀŒÀŒ#ÀŒ)ÀŒwÀŒ­ÀŒ³ÀÀyÀİÀCÀIÀšÀàÀûÀÀNÀ¡ÀáÀçÀ3ÀÀËÀ‘À‘hÀ‘À‘ À‘³À‘ÆÀ‘àÀ‘şÀ’&À’@À’SÀ’pÀ’—À’ÓÀ’æÀ“À“PÀ“¸À“¹À”À”zÀ”¾À”ÔÀ•>À•KÀ•´À•ÊÀ–VÀ–\À–`À–aÀ–±À–ÏÀ–ÕÀ— À—nÀ—©À—¯À—şÀ˜OÀ˜™À˜èÀ™9À™ŠÀ™ÚÀ™üÀšÀšRÀš“Àš™ÀšûÀ›]À›ÀÀœ%Àœ+ÀœzÀœÊÀœíÀœóÀ@À“ÀÓÀåÀøÀÀ0ÀXÀuÀ˜À²ÀÙÀÿÀŸ;ÀŸNÀŸ{ÀŸ¸À  À 4À ©À ­À ®À ëÀ¡À¡À¡{À¡şÀ¡ÿÀ¢~À¢›À¢±À¢ÇÀ¢ÜÀ¢ôÀ£À£'À£DÀ£EÀ£åÀ¤À¤À¤-À¤GÀ¤ZÀ¤mÀ¤…À¤À¤¼À¤ĞÀ¤íÀ¤îÀ¥tÀ¥À¥¦À¥¼À¥ÔÀ¥óÀ¦À¦ À¦7À¦SÀ¦TÀ¦wÀ¦­À¦ËÀ¦ëÀ§CÀ§KÀ§XÀ§ˆÀ§äÀ§ìÀ§òÀ§öÀ§øÀ§ùÀ¨7À¨_À¨…À¨‹À¨ÇÀ©À©\À©À©”À©äÀª3ÀªAÀªGÀªÀªÔÀ«À«À«MÀ«À«êÀ¬À¬#À¬qÀ¬“À¬šÀ¬¼À¬ÌÀ¬ìÀ­*À­0À­DÀ­·À­ĞÀ­îÀ­ôÀ­øÀ­ùÀ®À®À®-À®=À®AÀ®BÀ®‚À®¢À®£À¯À¯À¯À¯ÛÀ° À°HÀ°dÀ°fÀ°gÀ°±À°ÆÀ°ÊÀ°ôÀ±DÀ±‚À±À±ÎÀ±âÀ²À²3À²RÀ²XÀ²hÀ²…À²˜À²¢À²¦À²§À²½À²¾À³À³	À³RÀ³—À³äÀ³úÀ´8À´}À´ÆÀµÀµ=Àµ…ÀµÇÀµâÀ¶À¶À¶OÀ¶À¶ÊÀ¶àÀ¶èÀ¶ìÀ¶íÀ·&À·yÀ·ÆÀ¸À¸eÀ¸zÀ¸¸À¸ÛÀ¸ÜÀ¹À¹\À¹ªÀ¹ÖÀºÀº1Àº?ÀºEÀºFÀº‚ÀºŸÀºĞÀºÖÀºÚÀºÛÀº÷À»À»À»3À»MÀ»NÀ»’À»²À»³À¼À¼BÀ¼CÀ¼wÀ¼ËÀ¼ÍÀ¼ÎÀ½À½À½:À½‚À½ÒÀ¾ À¾FÀ¾JÀ¾—À¾äÀ¿2À¿{À¿´À¿ßÀÀHÀÀdÀÀsÀÀ•ÀÀ²ÀÀ¹ÀÀ½ÀÀ¾ÀÀÚÀÀÛÀÁÀÁGÀÁHÀÁ|ÀÁ‚ÀÁĞÀÂÀÂiÀÂ·ÀÃÀÃ1ÀÃ7ÀÃ~ÀÃ„ÀÃ’ÀÃ®ÀÃĞÀÃïÀÄ
ÀÄÀÄÀÄhÀÄrÀÄxÀÄ†ÀÄ×ÀÅÀÅ3ÀÅdÀÅjÀÅÀÅèÀÆ3ÀÆ~ÀÆÉÀÆÏÀÆöÀÇ ÀÇ(ÀÇ2ÀÇ8ÀÇ…ÀÇÚÀÇëÀÇñÀÈ;ÀÈfÀÈ»ÀÈ×ÀÈÛÀÈÜÀÉÀÉÀÉpÀÉ³ÀÉ¹ÀÊÀÊ'ÀÊXÀÊ¬ÀÊ×ÀÊÛÀÊÜÀËÀË$ÀËsÀË¿ÀËúÀÌÀÌÀÌ.ÀÌPÀÌ`ÀÌdÀÌeÀÌÊÀÍ0ÀÍ1ÀÍœÀÍÙÀÍÚÀÎ6ÀÎ[ÀÎ\ÀÎ¯ÀÎËÀÎÍÀÎÎÀÏÀÏ#ÀÏFÀÏƒÀÏ•ÀÏİÀÏêÀÏëÀĞ9ÀĞJÀĞKÀĞœÀĞ±ÀĞ·ÀÑÀÑ@ÀÑÀÑÀÑ’ÀÑ“ÀÑËÀÑÏÀÒÀÒdÀÒ¯ÀÒûÀÓKÀÓqÀÓuÀÓÂÀÔÀÔ_ÀÔoÀÔsÀÔ¿ÀÕÀÕ]ÀÕªÀÕ÷ÀÖGÀÖ–ÀÖãÀÖşÀ×À×OÀ×™À×æÀØÀØÀØ[ÀØ ÀØíÀÙ>ÀÙÀÙßÀÚÀÚ9ÀÚ€ÀÚ†ÀÚÔÀÛ!ÀÛoÀÛºÀÛéÀÛïÀÜ<ÀÜeÀÜkÀÜ¼Àİ
ÀİYÀİ–Àİ´ÀİºÀŞ	ÀŞXÀŞ^ÀŞ°ÀŞÙÀŞßÀß/Àß€ÀßÑÀàÀàkÀà¶ÀáÀáÀáÀáeÀáÀá•ÀáÓÀáÙÀâ%ÀâvÀâÇÀãÀã:ÀãFÀã[ÀãyÀã’Àã¸ÀãĞÀã×ÀäÀäaÀägÀä¾ÀåÀåÀå6ÀåvÀå¨ÀåÇÀæÀæZÀæ¥Àæ²Àæ¼ÀæÄÀæÊÀçÀç`ÀçÀç›ÀçÏÀçğÀçşÀè5ÀèZÀèhÀèiÀèÙÀéÀé!Àé%Àé&ÀéwÀé¦Àé¬ÀéúÀêGÀê•ÀêàÀëÀëÀëbÀë¬ÀëøÀìGÀìZÀì`Àì±Àí ÀíGÀí˜ÀíéÀî8ÀîoÀîuÀîÄÀïÀïdÀï­ÀïæÀïìÀğ<ÀğÀğŞÀñ.ÀñxÀñÄÀòÀòBÀòHÀò–ÀòæÀó5ÀócÀóiÀó§Àó·ÀóÌÀóéÀô Àô%Àô>ÀôEÀôjÀôÚÀôàÀõ#ÀõnÀõtÀõËÀö"Àö(ÀöCÀöƒÀö¹ÀöØÀ÷$À÷pÀ÷»À÷ÈÀ÷ÒÀ÷ÚÀ÷àÀø4ÀøvÀø|Àø€ÀøÀøãÀùÀù=ÀùqÀù¯ÀùßÀúÀúÀúcÀú†Àú™Àú±ÀúÁÀúÙÀúìÀúöÀûÀû
ÀûÀûVÀû{ÀûÀÀûÜÀûİÀû÷ÀüAÀüGÀü•Àü«ÀüÆÀüÚÀüêÀıÀıÀı#Àı”Àı˜ÀıšÀı›ÀıéÀıíÀş)ÀşmÀş~Àş Àş¦ÀşôÀÿ>ÀÿwÀÿ}ÀÿÊÀ À /À 9À :À tÀ zÀ ÀÀ ÆÀÀÀ'À(À^ÀdÀ¦À¼ÀÇÀÉÀÊÀÀ À$ÀCÀQÀ‰À—À˜ÀÑÀŞÀàÀáÀÀÀaÀ¥ÀæÀêÀ3ÀƒÀÌÀéÀíÀ=À†À»À¿ÀÀKÀcÀ¦ÀÄÀÊÀÀ[À«ÀúÀGÀŠÀÀ×ÀíÀ	=À	>À	†À	ŒÀ	¸À	¾À	ÎÀ	ÔÀ
%À
ZÀ
iÀ
jÀ
»ÀÀ[À¤À³À¹ÀÀVÀ¤ÀìÀ:À„ÀŠÀ×ÀİÀÀÀUÀ¡ÀñÀAÀfÀlÀºÀÀTÀ¢ÀğÀ@ÀˆÀµÀ»ÀÀÀ$À2À_À‡ÀÀŞÀÀ>ÀwÀ‘À«À³À½ÀÃÀÀ`À®ÀÌÀÒÀàÀÀPÀxÀÀÏÀÀ?ÀYÀaÀkÀqÀÂÀÀRÀXÀfÀ“ÀªÀşÀ7ÀQÀhÀÉÀÀÀ$À.À4ÀÀÈÀÀQÀWÀ{ÀÀÀÀÆÀÀbÀ³ÀşÀMÀ›ÀæÀ1À‚ÀÓÀîÀôÀÀ
ÀZÀ|ÀÄÀÚÀÀÀHÀgÀmÀ¬À²ÀûÀ ?À QÀ RÀ ®À ûÀ!MÀ!SÀ!’À!˜À!æÀ"6À"XÀ"zÀ"{À"¾À#À#JÀ#À#…À#ªÀ#ÀÀ#ÁÀ$À$aÀ$‰À$ŠÀ$ÙÀ%#À%4À%:À%€À%’À%¹À%ºÀ&À&.À&/À&€À&ÌÀ'À'DÀ'gÀ'hÀ'¸À'óÀ(À(À(nÀ(ÄÀ(àÀ(æÀ)8À)†À)ÖÀ*À*!À*"À*pÀ*‡À*À*ãÀ*éÀ+-À+3À+…À+ÍÀ+öÀ+üÀ,FÀ,ZÀ,µÀ,¶À-À-#À-)À-€À-†À-ÊÀ-ĞÀ."À.jÀ.ºÀ.ôÀ.õÀ/CÀ/WÀ/]À/³À/¹À/ıÀ0À0UÀ0À0ÆÀ0ıÀ0şÀ1OÀ1¡À1ôÀ2À2À2_À2²À3À3SÀ3¢À3õÀ4HÀ4—À4èÀ5À5
À5BÀ5”À5èÀ67À6yÀ6À6ÍÀ6ôÀ6úÀ7À7)À7HÀ7À7¾À7İÀ8À8SÀ8bÀ8jÀ8tÀ8zÀ8ËÀ9À9rÀ9ÆÀ9ÖÀ9ÜÀ:"À:oÀ:£À:©À:ùÀ;HÀ;”À;¬À;ÁÀ;ŞÀ;ßÀ<0À<‚À<ÕÀ<ÛÀ=+À=}À=ÍÀ>À>oÀ>ÃÀ?À?#À?)À?^À?À?‚À?ÅÀ@À@.À@bÀ@cÀ@²À@úÀA ÀANÀATÀA¿ÀB.ÀBbÀBcÀB’ÀB˜ÀBİÀBøÀCÀCÀChÀC£ÀC©ÀDÀDƒÀD¬ÀD­ÀDşÀE@ÀEFÀE²ÀF"ÀFNÀFOÀFŸÀFïÀGÀGÀG`ÀGšÀG›ÀGèÀH9ÀH\ÀHbÀHÍÀI<ÀIeÀIfÀI±ÀJÀJRÀJuÀJ{ÀJèÀKYÀK’ÀK“ÀKÏÀKÕÀLÀLbÀL¬ÀM ÀMQÀM¡ÀMÍÀMÓÀNBÀNµÀN»ÀOÀOqÀOrÀO§ÀO­ÀOöÀP?ÀPkÀP”ÀP•ÀPãÀQ:ÀQuÀQvÀQÅÀRÀRÀRfÀRÀR…ÀRÑÀSÀS-ÀSqÀSrÀS¹ÀS¿ÀTÀT[ÀT¨ÀTõÀU8ÀU>ÀUŒÀUÙÀV'ÀVnÀVÀVÆÀVÇÀWÀW'ÀWLÀWMÀW™ÀW©ÀW¯ÀWúÀXÀXÀXYÀX¦ÀXäÀXêÀY9ÀY…ÀY‹ÀYÜÀZ)ÀZvÀZ|ÀZÆÀ[À[_À[™À[šÀ[ßÀ[åÀ\,À\2À\xÀ\ÂÀ\ÈÀ\ØÀ\ŞÀ].À]GÀ]‘À]’À]×À]İÀ^-À^zÀ^€À^ÆÀ_À_À_&À_,À_zÀ_˜À_äÀ_åÀ`/À`5À`À`’À`˜À`áÀa2ÀaIÀaOÀa˜ÀaæÀb2ÀbzÀbÊÀcÀc`Àc¯ÀcüÀdFÀd€Àd†Àd­Àd³ÀdÃÀeÀe`Àe‡ÀeÙÀf#Àf$ÀfhÀfnÀf¿ÀgÀgkÀg¿Àg÷ÀgıÀhMÀhÀhíÀi?ÀiÀiãÀj/Àj5Àj†ÀjÖÀk+Àk‚Àk²ÀlÀlTÀl˜ÀlÀlñÀm@Àm‹ÀmÙÀn.Àn4ÀnˆÀnÙÀo"Ào(ÀoyÀo”ÀošÀo¨Ào½ÀoæÀoùÀpÀpÀpÀpLÀp‚ÀpˆÀpáÀpÿÀq Àq&Àq8ÀqgÀqˆÀq¿ÀqóÀrÀr<ÀrXÀr•Àr³ÀrÑÀsÀsEÀssÀs„Às™ÀsÍÀtÀt7ÀtAÀtGÀtVÀt^ÀthÀtnÀtÇÀtÍÀtÛÀtğÀu4ÀuGÀu^ÀuqÀuŠÀu’Àu˜ÀuÆÀuüÀvÀv[ÀvyÀvšÀv Àv²ÀváÀwÀw9ÀwmÀw—ÀwÂÀwŞÀxÀx9ÀxWÀxÀxËÀxùÀy
ÀyÀySÀy–Ày¬ÀyàÀzÀz@ÀzJÀzPÀz_ÀzgÀzqÀzwÀzÀÀ{À{>À{DÀ{TÀ{ZÀ{¨À{¿À{İÀ|À|/À|UÀ||À|À|¼À|½À}À}À}XÀ}±À~À~XÀ~ªÀ~üÀ3À9À‰ÀÑÀ×À€(À€hÀ€“À€™À€çÀ1À7ÀƒÀĞÀ‚ À‚&À‚À‚’À‚˜À‚¦À‚»À‚äÀ‚÷ÀƒÀƒÀƒÀƒJÀƒ€Àƒ†ÀƒßÀƒıÀ„À„$À„6À„eÀ„µÀ…À…UÀ…qÀ…¶À† À†8À†cÀ†™À†ÂÀ†éÀ‡À‡AÀ‡GÀ‡ À‡ûÀˆUÀˆ—ÀˆÃÀˆïÀ‰.À‰mÀ‰yÀ‰šÀ‰øÀŠÀŠÀŠÀŠÀŠ)ÀŠ/ÀŠˆÀŠÀŠœÀŠ±ÀŠõÀ‹À‹À‹2À‹KÀ‹SÀ‹YÀ‹‡À‹½À‹ÃÀŒÀŒ:ÀŒ[ÀŒaÀŒsÀŒ¢ÀŒòÀAÀ’À®ÀóÀ=À{À³ÀŞÀÀ=ÀdÀ”À¼ÀÂÀÀtÀÏÀ‘,À‘wÀ‘½À‘æÀ’ À’;À’WÀ’sÀ’·À’ãÀ“À“À“UÀ“ŒÀ“ÁÀ“öÀ“üÀ”VÀ”°À•À•OÀ•~À•ŠÀ•«À–À–#À–)À–8À–@À–JÀ–PÀ–`À–fÀ–³À–ÈÀ–éÀ—À—?À—fÀ—À—´À—ÖÀ—×À˜$À˜*À˜zÀ˜À˜•À˜»À™À™À™À™cÀ™¤À™ÄÀš!Àš'Àš[ÀšzÀš™ÀšõÀšùÀšúÀ›dÀ›ÙÀ›ÚÀœ6Àœ’Àœ×ÀœüÀœıÀ	ÀWÀoÀpÀ“À«ÀÇÀğÀÀBÀkÀtÀzÀ‹ÀÀÀœÀÊÀäÀŸ ÀŸ-ÀŸQÀŸ¶ÀŸ¼ÀŸÀÀŸÁÀ #À }À ~À óÀ¡vÀ¡wÀ¡ƒÀ¡ÔÀ¡ïÀ¡ğÀ¡üÀ¢[À¢†À¢‡À¢“À¢êÀ£	À£
À£À£yÀ£ªÀ£«À£·À£öÀ£÷À¤VÀ¤„À¤…À¤‘À¤éÀ¥À¥À¥À¥|À¥¨À¥©À¥µÀ¥İÀ¥ıÀ¦;À¦AÀ¦ZÀ¦^À¦_À¦¬À¦İÀ¦ŞÀ¦êÀ§	À§:À§VÀ§jÀ§nÀ§oÀ§¿À§óÀ§ôÀ¨ À¨\À¨|À¨–À¨ãÀ©1À©sÀ©ËÀ©ÏÀ©ĞÀªOÀª¾Àª¿ÀªËÀ«À«(À«ZÀ«^À«_À«²À«óÀ«ôÀ¬ À¬8À¬iÀ¬mÀ¬nÀ¬ÇÀ­À­À­À­1À­`À­À­ÇÀ­ËÀ­ÌÀ®"À®[À®\À®hÀ®ŒÀ®»À®âÀ¯(À¯,À¯-À¯‰À¯ÈÀ¯ÉÀ¯ÕÀ°
À°8À°<À°=À°ŸÀ°ÕÀ°ÖÀ°âÀ±À±7À±WÀ±ŸÀ±£À±¤À²À²À²‘À²À²½À²êÀ²îÀ²ïÀ³DÀ³‘À³’À³À³ÈÀ³èÀ´À´@À´œÀ´¢À´¦À´§ÀµÀµÀµÀµªÀµ×ÀµùÀ¶;À¶?À¶@À¶À¶ıÀ¶şÀ·
À·EÀ·gÀ·‰À·áÀ·åÀ·æÀ¸LÀ¸ÀÀ¸ÁÀ¸ÍÀ¸÷À¹À¹1À¹oÀ¹ËÀ¹ÑÀ¹ÕÀ¹ÖÀºJÀºÌÀºÍÀºÙÀ»À»2À»tÀ»xÀ»yÀ»çÀ¼XÀ¼YÀ¼eÀ¼ÄÀ¼äÀ½`À½dÀ½eÀ½îÀ¾À¾À¾-À¾AÀ¾VÀ¾oÀ¾ˆÀ¾À¾ÁÀ¾ÜÀ¾İÀ¾éÀ¿À¿TÀ¿XÀ¿YÀ¿¼ÀÀÀÀÀÀ'ÀÀcÀÀ…ÀÀ©ÀÁ+ÀÁDÀÁ’ÀÁ˜ÀÁœÀÁÀÂÀÂ¤ÀÂ¥ÀÂ±ÀÂöÀÃÀÃ7ÀÃVÀÃÀÃÀÀÃòÀÄ&ÀÄ[ÀÄÀÄÀÀÄôÀÅ)ÀÅbÀÅ˜ÀÅİÀÅöÀÆDÀÆJÀÆNÀÆOÀÇ ÀÇ#ÀÇ7ÀÇMÀÇbÀÇyÀÇ‘ÀÇ§ÀÇ¼ÀÇÓÀÇëÀÈÀÈ(ÀÈGÀÈHÀÈTÀÈœÀÈ¾ÀÈàÀÈÿÀÉ6ÀÉlÀÉ¡ÀÉØÀÊÀÊCÀÊuÀÊ©ÀÊŞÀËÀËMÀË’ÀË«ÀËùÀËÿÀÌÀÌÀÌµÀÌØÀÌìÀÍÀÍÀÍ7ÀÍRÀÍhÀÍ}ÀÍ”ÀÍ¬ÀÍÏÀÍéÀÎÀÎ	ÀÎÀÎ;ÀÎ_ÀÎŒÀÎÀÎ‘ÀÎçÀÏÀÏÀÏ*ÀÏeÀÏ±ÀÏİÀĞÀĞ,ÀĞdÀĞhÀĞiÀĞuÀĞÀÀÑÀÑÀÑÀÑ*ÀÑwÀÑ™ÀÑäÀÑêÀÒ1ÀÒ5ÀÒ6ÀÒ›ÀÓÀÓÀÓÀÓdÀÓ‰ÀÓÔÀÓØÀÓÙÀÔGÀÔ¹ÀÔºÀÔÆÀÔäÀÕÀÕ6ÀÕ\ÀÕƒÀÕ¤ÀÕÄÀÕæÀÖ)ÀÖ*ÀÖRÀÖ|ÀÖÇÀÖÍÀ×À×‚À×ˆÀ×‰À×ĞÀØÀØÀØ:ÀØZÀØÀØ¤ÀØÉÀØÿÀÙ!ÀÙCÀÙyÀÙ¯ÀÙãÀÚÀÚ=ÀÚbÀÚ‰ÀÚ±ÀÚ·ÀÚ¸ÀÛ!ÀÛbÀÛšÀÛ›ÀÛÁÀÜ ÀÜfÀÜmÀÜnÀÜ‡ÀÜÕÀÜÛÀÜßÀÜàÀÜìÀİÀİ<ÀİcÀİŠÀİ´ÀİØÀİûÀŞ,ÀŞ-ÀŞUÀŞ‚ÀŞĞÀŞÖÀŞôÀßRÀßXÀß”ÀàÀàÀàKÀàLÀàrÀàÇÀáÀáÀáÀá2Àá€Àá†ÀáŠÀá‹ÀâÀâ>ÀâaÀâ{Àâ™Àâ­ÀâÎÀâçÀã ÀãÀã3Àã4Àã@Àã˜ÀãëÀãïÀãğÀä[ÀäÁÀäÂÀäÎÀåÀåÀåÀåAÀå€ÀåÀåÉÀåÍÀæÀæÀæLÀæÀæĞÀæéÀç(Àç.ÀçyÀç»ÀçÜÀèÀèÀèGÀèMÀè˜ÀèÛÀèüÀé&Àé'ÀéQÀéWÀé¦ÀéõÀê>ÀênÀêoÀê±Àê·ÀêîÀë=ÀëŒÀëÕÀëÛÀì+ÀìyÀì¦Àì¬ÀìüÀíEÀí^ÀídÀí³ÀíÈÀíôÀíõÀîEÀîhÀîzÀî{ÀîÁÀîÇÀïÀï+ÀïEÀïFÀïÀï•ÀïæÀğÀğ8Àğ:Àğ;Àğ‹ÀğÕÀğñÀğ÷Àñ-ÀñCÀñDÀñPÀñÀñ™Àñ¾ÀñòÀñøÀòÀò^Àò{Àò•Àò¦ÀòåÀòïÀòùÀó ÀóÀóÀócÀó¸Àó¹ÀóÅÀóòÀô
Àô/ÀôcÀôiÀôjÀôÀô·ÀôíÀôñÀôòÀõRÀõ˜Àõ™Àõ¥Àõ¸ÀõĞÀõàÀõøÀöÀöÀö8ÀöHÀöLÀöMÀö˜Àö½À÷À÷À÷À÷8À÷9À÷EÀ÷`À÷tÀ÷„À÷ À÷³À÷½Àø-Àø1Àø2Àø>ÀøœÀøÅÀøÆÀøÒÀøôÀøöÀø÷Àù>ÀùBÀù‡ÀùÌÀùíÀú.ÀúuÀú‘ÀúÇÀúÈÀûÀû	ÀûMÀû”ÀûËÀüÀüLÀüdÀüeÀü”ÀüšÀüåÀı5ÀızÀı”Àı–Àı—Àı÷Àş&Àş'ÀşkÀş‹ÀşŒÀş˜ÀşÃÀşÄÀşĞÀşëÀÿÀÿJÀÿPÀÿ‡Àÿ£ÀÿÂÀÿÖÀ )À pÀ •À ©À ­À ®ÀÀAÀBÀ\À]ÀiÀ¬À®À¯ÀÄÀÈÀÀÀ-À3À~ÀÉÀãÀéÀ*À0ÀÀ˜À©À×ÀöÀÀfÀgÀ—À»ÀåÀÀ7À^ÀˆÀ‰À¹À¿ÀÀ4ÀIÀJÀ‰ÀÀİÀ)ÀkÀ‚ÀƒÀÕÀğÀñÀ#À)À\ÀbÀÀ	À	8À	lÀ	pÀ	qÀ	­À	³À	æÀ
"À
#À
pÀ
vÀ
³ÀÀ)À/ÀsÀ¼ÀÀ-ÀAÀTÀjÀ­À±À²ÀÀÀ2ÀEÀYÀxÀŸÀ¦ÀªÀ«ÀÛÀáÀ*ÀoÀ“À™À¿ÀÀVÀ¡ÀíÀ;À‹ÀØÀÀ"ÀqÀ‘À¦ÀŞÀóÀ
ÀÀ.ÀOÀWÀdÀ{À–À¥À¼ÀïÀ&ÀhÀsÀ{ÀÀ…À†À¿ÀÅÀÀÀ6À„À¦À¹À¿ÀÕÀëÀÀRÀ‚À±À·ÀîÀÀÀRÀsÀyÀŒÀÀ‘ÀÀÀÀâÀõÀûÀÀ6ÀXÀƒÀ‡ÀˆÀ”ÀÒÀÓÀÀqÀÀÇÀâÀüÀÀÀ@ÀvÀwÀ‘ÀŞÀÀEÀFÀÀÆÀÇÀşÀ+À,ÀcÀÀ‘ÀàÀÀ@ÀFÀGÀ_ÀcÀdÀpÀ³ÀµÀ¶ÀıÀÀPÀfÀ¤ÀÇÀÈÀÀ+ÀlÀ±ÀãÀÀ.À2À3ÀmÀsÀ¬ÀêÀ /À xÀ ÂÀ ïÀ!7À!rÀ!£À!ßÀ!úÀ"À"@À"HÀ"qÀ"yÀ"}À"~À"¯À"µÀ"îÀ#+À#fÀ#—À#ÌÀ#çÀ$À$;À$CÀ$lÀ$tÀ$xÀ$yÀ$ÍÀ%À%À%oÀ%¼À%½À&À&eÀ&fÀ&šÀ&·À&ÆÀ&ÇÀ&æÀ&çÀ'À'À'gÀ'‚À'šÀ'ªÀ'ËÀ'ŞÀ'èÀ'ıÀ(À(À(RÀ(uÀ({À(ÈÀ)À)_À)¬À)úÀ*À*+À*;À*ZÀ*wÀ*ŠÀ*”À*¤À*¨À*©À*ôÀ+À+eÀ+À+ƒÀ+„À+ÏÀ+ÓÀ,"À,:À,[À,”À,šÀ,êÀ-<À-VÀ-\À-ªÀ-ıÀ.>À.{À.šÀ.¸À.ĞÀ.éÀ.üÀ/"À/EÀ/FÀ/‘À/ÔÀ0À0PÀ0ˆÀ0¨À0¬À0­À0×À0İÀ1À1)À1*À1UÀ1[À1–À1¨À1©À1ÛÀ1áÀ2À21À22À2‚À2¥À2«À2öÀ3À3-À3.À3|À3˜À3À3éÀ46À4GÀ4MÀ4›À4ÃÀ5À5À5À5oÀ5À5À5ÇÀ5ÍÀ6À6oÀ6‰À6À6İÀ70À7qÀ7®À7ÌÀ7êÀ8À8À8.À8TÀ8[À8oÀ8…À8ÊÀ8âÀ90À94À95À9—À9êÀ9ëÀ:TÀ:âÀ:ãÀ:òÀ:óÀ;LÀ;hÀ;iÀ;uÀ; À;¡À;±À;²À<À<)À<*À<6À<dÀ<eÀ<|À<}À<ŞÀ=À=À=À=RÀ=SÀ=_À=«À=ÆÀ=ÇÀ=ÓÀ>#À>VÀ>pÀ>vÀ>«À>ÆÀ>ÌÀ>ÍÀ?À?À?<À?zÀ?¹À?÷À@-À@3À@TÀ@vÀ@wÀ@¡À@ÜÀ@îÀ@òÀ@óÀA^ÀA´ÀAµÀAÁÀBJÀBLÀBMÀB‚ÀB²ÀB³ÀBñÀC9ÀC:ÀCrÀCvÀCÀÀCÍÀDÀDÀDRÀDnÀDÃÀDÄÀEÀE(ÀE+ÀExÀE•ÀE˜ÀEäÀEçÀEùÀEüÀFÀF;ÀF>ÀFyÀF¶ÀF»ÀF¾ÀFİÀGÀGÀGÀGÀGqÀGÇÀGóÀGöÀHLÀH€ÀH¶ÀHıÀIAÀI~ÀI”ÀIÀÀIÕÀIéÀJÀJ%ÀJeÀJmÀJzÀJ—ÀJÀJ£ÀJµÀJÌÀJèÀJìÀKÀK	ÀK
ÀKMÀK“ÀKÉÀLÀLTÀL‘ÀL§ÀLâÀL÷ÀMÀM!ÀM5ÀMkÀMzÀMÃÀMËÀMÑÀM×ÀMéÀN ÀNÀN ÀN;ÀN=ÀN>ÀNÀNÛÀNßÀO/ÀOÀO´ÀOïÀP4ÀP5ÀPjÀP‚ÀPƒÀPÕÀPğÀPñÀPıÀQÀQmÀQ†ÀQÀQåÀRÀRÀR2ÀR6ÀR8       ,‡ŞªŒĞ„ë/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c1 = const Color(0xFF42A5F5);
/// Color c2 = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c3 = const Color.fromARGB(255, 66, 165, 245);
/// Color c4 = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
///    defines the colors found in the Material Design specification. ŒÚ‚Ñ }‚‚|/// Construct a color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).ƒ	ˆ  –˜ ¯‚‚‘v‘w‘£/// Construct a color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.‘€‘…  ‘‡‘Œ  ‘‘“  ‘•‘š  -‘¨‘¢’$‘ª’"’‘à‘¾‘«‘¼‘·‘¬‘µ‘¯‘­‘±‘º‘Í‘Ş‘Ù‘Î‘×‘Ñ‘Ï‘Ó‘Ü‘ï‘ÿ‘û‘ğ‘ù‘ó‘ñ‘õ‘ş’’!’’’’’’’ ’&’5ƒ ”!”"”*Ê/// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.”+”0  ”2”7  ”9”>  ”@”H  3”\”V•(”^•&”ò”¼”†”_”„””`”}”w”a”u”q”j”b”l”t”y”‚”–”º”µ”—”³”­”˜”¯”¸”Ì”ï”ë”Í”é”ã”Î”å”î••%•!••••••$•*•9–?€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value. –I€Ü—€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.   —)€Ï—à€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.   —üa˜;4/// The red channel of this color in an 8 bit value.   ˜ad˜¢6/// The green channel of this color in an 8 bit value.   ˜Éb™	5/// The blue channel of this color in an 8 bit value.   ±Y/±m   ±Y±Z™/	™ò€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ™üš   š<U›€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. ››%   ›•œV€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. œ^œc   œ 	c€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. mr   ­o€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. x}   ÷€ÅŸ  ŸŸ&   ŸÀ‚K Î€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   ¢‡A§„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. §§  § §(  §*§2   ©T† «hö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. «s«z  «…«Œ   ¯x€í°w/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. °°   °i€ì°ƒ  °†°  °i°j±ŒW±Ÿ   ±Œ± À ¬…À BçÀ ­<€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À ­Ff À ­¤À ­©Y/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  $À °ŒLÀ °· 	À °ŒÀ °À °“À °¤À °”À °¿À °ÇÀ °×À °ÈÀ °İ'À °î À ±À ±!À ± À ±(À ±-%À ±> À ±QÀ ±V!À ±g À ±vÀ ±{'À ±Œ À ±¡À ±¦%À ±· À ±ÊÀ ±Ï&À ±à À ±ôÀ ±ù,À ²
 À ²$À ²))À ²: À ²QÀ ²V&À ²g À ²{À ²€0À ²‘ À ²®À ²´,À ²Å À ²ŞÀ ²ä(À ²õ À ³
À ³>À ³" À ³KÀ ³8À ³NÀ ³S2À ³d À ³À ³tÀ ³„À ³‰:À ³š À ³¿À ³®À ³ÂÀ ³Ç2À ³Ø À ³õÀ ³èÀ ³øÀ ³ı>À ´ À ´7À ´$À ´:À ´?:À ´P À ´uÀ ´dÀ ´xÀ ´}<À ´ À ´µÀ ´£À ´¸À ´½HÀ ´Î À µÀ ´éÀ µÀ µ	BÀ µ À µGÀ µ2À µJÀ µO<À µ` À µ‡À µuÀ µŠÀ µNÀ µ  À µÙÀ µ¾À µÜÀ µáFÀ µò À ¶#À ¶À ¶&À ¶+>À ¶< À ¶eÀ ¶RÀ ¶hÀ ¶¯%À ¶À À ¶ÒÀ ·W3À ·‚ À ·WÀ ·XÀ ·^À ·oÀ ·_À ¸"À ¸ À ¸&À ¸+'À ¸< À ¸QÀ ¸V'À ¸g À ¸|À ¸"À ¸’ À ¸¢À ºî,À ºÿ À »À ¾=À ¾& À ¾;À ¾DÀ ¾EÀ ¾LÀ ¾MÀ ÍL3À Í` À Í|À ¸Ö€ÓÀ ¹Qi/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À ¹¬À ¹°  À ¹¼
À ¹Â   À »‚'À ¼Æ„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À ½I€À ½M  À ½SÀ ½Z   À ¾WƒœÀ Á\‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À Áö€ À Áú  À ÂÀ Â   À Âš€áÀ Ãk/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À Ã~€‡À Ã‚  À ÃˆÀ Ã—   À Ä	iÀ Å€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À Åu€‹À Åy  À Å…À Å   À ÆÀ Æ»€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À Ç€‹À Ç#  À Ç-À Ç8   À Ç®„ÑÀ Ì„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À Ì‚€À Ì†  À Ì‘À Ì   À Í„…rÀ Ò—„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À Òù€±À Òı  À ÓÀ Ó   À Ó®‚WÀ Ôv€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À Ö‚°À Ö  À ÖÀ Ö$   À Ø¼ìÀ Ú;/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À Ú«€—À Ú¯  À Ú½À ÚÌ   À ÛFÈÀ ÜÒk/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À İïÀ İ  À İÀ İ%   À ßvÀ ßğ€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À à}<À à  À àÀ à›   À á½‚ˆÀ ã»È/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     _image,
///     ui.Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: 0.5, sigmaY: 0.5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À äH·À äL  À äXÀ äf   À ænÀ ç/// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À çtlÀ çx  À ç…
À ç‹   À ·rÀ ·    À çä‡†À ç÷   À çäÀ çå À ÿş¦hÀ£„/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. À­€ÁÀ²À³À´ ÀµÀ»  ÀÂ
ÀÈ  ÀÎÀÔ   À“/À¼ À“À”ÀšÀ«À›ÀÇÀÔ€ç/// A callback that is invoked to report an image creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀáÀğ€é/// A callback that is invoked to report the image disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀşÀ
  ÀSÀhA/// The number of image pixels along the image's horizontal axis. ÀrRÀ¾?/// The number of image pixels along the image's vertical axis. ÀÉÀÎ ÀÚÀ•ÀÄ€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀtƒÀÛÌ/// The color space that is used by the [Image]'s colors.
///
/// This value is a consequence of how the [Image] has been created.  For
/// example, loading a PNG that is in the Display P3 color space will result
/// in a [ColorSpace.extendedSRGB] image.
///
/// On rendering backends that don't support wide gamut colors (anything but
/// iOS impeller), wide gamut images will still report [ColorSpace.sRGB] if
/// rendering wide gamut colors isn't supported.   Àãƒ&À
ãæ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   À¦ƒÊÀÑÍ/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Using [ImageByteFormat.rawRgba] on an image in the color space
/// [ColorSpace.extendedSRGB] will result in the gamut being squished to fit
/// into the sRGB gamut, resulting in the loss of wide-gamut colors.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. Àİ0Àî  ÀöÀÀÀ¢ÀÓ€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   À®ŒàÀ!ïŠ¢/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
/// import 'dart:typed_data';
/// import 'dart:ui';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageHolder(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   À#’‚›À%ü‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. À&À&   À&13À&D   À&1À&2 À&h‡ØÀ&  À'’'À'´À'µÀ'¶  À'’À'“À'™À'ªÀ'šÀ+$À+) À+5À-u%À-† À-˜À-™À-‘À-—À-’À'½fÀ(   À'½À'¾À'ÄÀ'âÀ'ËÀ'ÅÀ'ÓÀ'áÀ'ÔÀ'ÛÀ'àÀ'ÜÀ'ãÀ(À'êÀ'äÀ'ìÀ(À'üÀ(À('hÀ(ˆ   À('À((À(.À(LÀ(5À(/À(=À(KÀ(>À(EÀ(JÀ(FÀ(MÀ(sÀ(TÀ(NÀ(VÀ(mÀ(gÀ(oÀ-ŸbÀ-ö   À-ŸÀ- À-¦À-ÄÀ-­À-§À-µÀ-ÃÀ-¶À-½À-ÂÀ-¾À-ÅÀ-áÀ-ÌÀ-ÆÀ-ÎÀ(“¡À(¥  À(±0À(Â  À(ÊÀ(ÙÀ(ÚÀ*8€èÀ*Û9/// Returns an error message on failure, null on success. À*ç
À*ì  À*ó+À+  À*tÀ*uÀ*{À*©À*ƒÀ*|À*‹À*¨À*ŒÀ*“À*˜À*”À*›À*¢À*ªÀ*ÆÀ*±À*«À*³À+>dÀ+C    À,¦€ËÀ-fk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À-À-À-À-:À-#À-À-+À-9À-,À-3À-8À-4À-;À-TÀ-BÀ-<À-DÀ.9À.   À.À.À&hÀ&iÀ&oÀ&€À&pÀ/#‰_À5ô†Ê/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` À6À6ÑÀ6ÒÀ6Ó€»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].À6ÕÀ6ä  À6íÀ6ü   À7€™À7˜{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. À7¥€ÚÀ8z€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    À8„„>À9r€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec].   À9|9À9ª#/// Number of frames in this image.   À9¹€¦À:O€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   À:caÀ;µ//// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   À;È€øÀ<¶€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À<Ä‡£À<Ï  À=×À=ãÀ=äÀ=å   À=ìÀ=ñ  À>ÄÀ>É  À>DÀ>   À>À>À>OqÀ>´   À>OÀ>PÀ>VÀ>tÀ>]À>WÀ>eÀ>sÀ>fÀ>mÀ>rÀ>nÀ>uÀ>ŸÀ>|À>vÀ>~À>™À>“À>›À>äSÀ>ø   À>äÀ>åÀ?;{À?¥   À?;À?<À?BÀ?`À?IÀ?CÀ?QÀ?_À?RÀ?YÀ?^À?ZÀ?aÀ?À?hÀ?bÀ?jÀ?ŠÀ?„À?ŒÀ?º‚õÀ?Ø   À?ºÀ?»ÀB³€ÚÀCQ9/// Returns an error message on failure, null on success. ÀC_,ÀC„  ÀBïÀBğÀBöÀCÀBşÀB÷ÀCÀCÀCÀCÀCÀCÀCÀCÀC<ÀC%ÀCÀC'ÀC‘fÀCí   ÀC‘ÀC’ÀCÀCÀC¤ÀCÁÀCªÀC¥ÀC²ÀCÀÀC³ÀCºÀC¿ÀC»ÀCÂÀCÛÀCÉÀCÃÀCËÀCûjÀD   ÀCûÀCü Àc®†jÀdÁ/// A specification of the size to which an image should be decoded.
///
/// See also:
///
///  * [TargetImageSizeCallback], a callback that returns instances of this
///    class when consulted by image decoding methods such as
///    [instantiateImageCodecWithSize]. ÀdÕ# ÀetÀeƒ€/// Creates a new instance of this class.
///
/// The `width` and `height` may both be null, but if they're non-null, they
/// must be positive.Àe…
Àe‹  Àe‘Àe—  Àe§Àe­ÀeÈÀe¼Àe´Àe®Àe·ÀeÅÀe¿ÀeÇÀeÓÀeÙÀeöÀeéÀeáÀeÚÀeäÀeóÀeìÀeõÀeüåÀgÜÂ/// The width into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified width.
/// If this is null and [height] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [height] is non-null, the image
/// will be decoded into a width that maintains its intrinsic aspect ratio
/// while respecting the [height] value.
///
/// If this value is non-null, it must be positive. ÀgææÀiÆÂ/// The height into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified height.
/// If this is null and [width] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [width] is non-null, the image
/// will be decoded into a height that maintains its intrinsic aspect ratio
/// while respecting the [width] value.
///
/// If this value is non-null, it must be positive.  ÀiÑEÀiä   ÀiÑÀiÒ Àƒ»ƒ˜À„P/// A handle for the framework to hold and retain an engine layer across frames.    À„+ƒ&À‡G‚ø/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À‡UIÀ‡`  À‡¯}Àˆ'Àˆ(Àˆ)a/// This class is created by the engine, and should not be instantiated
/// or extended directly.    Àˆ0lÀˆ’   Àˆ0Àˆ1Àˆ<Àˆ=ÀˆCÀˆ`ÀˆIÀˆDÀˆQÀˆ_ÀˆRÀˆYÀˆ^ÀˆZÀˆaÀˆ€ÀˆhÀˆbÀˆj Àˆ ¸XÀ‹h‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. À‹q À‹yÀ‹}   À‹’iÀŒhÀŒiÀŒm€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.ÀŒnÀŒt    ÀŒÿ€£À™€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   À¥!À©  À²ÀÀ   ÀÊUÀ2/// Starts a new sub-path at the given coordinate. ÀÀ  ÀÀ   À#rÀpE/// Starts a new sub-path at the given offset from the current point. À	À‡  ÀŠ	À’   À™tÀòO/// Adds a straight line segment from the current point to the given
/// point. ÀùÀ  ÀÀ   À€£Àt/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. À	À¦  À©	À±   À¸ÁÀ‘;q/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to_dark.png#gh-dark-mode-only) À‘M	À‘U  À‘X	À‘`  À‘c	À‘k  À‘n	À‘v   À‘}'À’^€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. À’x	À’€  À’ƒ	À’‹  À’	À’–  À’™	À’¡   À’¨ÎÀ”,r/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to_dark.png#gh-dark-mode-only) À”4	À”<  À”?	À”G  À”J	À”R  À”U	À”]  À”`	À”h  À”k	À”s   À”z=À•e€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. À•u	À•}  À•€	À•ˆ  À•‹	À•“  À•–	À•  À•¡	À•©  À•¬	À•´   À•»‚bÀ—ß‚/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to_dark.png#gh-dark-mode-only) À—ç	À—ï  À—ò	À—ú  À—ı	À˜  À˜	À˜  À˜À˜   À˜!ÏÀ™ªw/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. À™º	À™Â  À™Å	À™Í  À™Ğ	À™Ø  À™Û	À™ã  À™æÀ™î   À™ôƒrÀƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. À#	À)  À.À6  ÀAÀI  ÀTÀZ   Àjƒ!ÀŸø‚p/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// À À   À À    À 9À A  À TÀ Z  À oÀ u  À (À .À /À KÀ dÀ €À ƒ£À£‚Ü/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. À£¥À£­  À£¿À£Ç  À£àÀ£è  À£ûÀ¤  À¤À¤  À£ÏÀ£ÕÀ£ÖÀ£òÀ¤À¤'À¤6vÀ¤™Y/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. À¤¡	À¤§   À¤°.À¥Ë/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. À¥Ó	À¥Ù   À¥âƒèÀ©’ƒ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_dark.png#gh-dark-mode-only)
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw_dark.png#gh-dark-mode-only) À©™	À©Ÿ  À©¤À©¬  À©·À©¿   À©ÎXÀªú/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. À«À«  À«
À«    À«*€°À«Ä€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. À«ÍÀ«Ô   À«ŞQÀ¬õ/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. À¬ı	À­  À­À­  À­À­&   À­3×À®É‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. À®Ø	À®Ş  À®ãÀ®ë  À®óÀ¯   À¯€“À¯™€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   À¯¥€±À°N€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   À°ZqÀ±´F/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. À±½À±Å   À±Ï€‰À²Cj/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. À²IÀ²Q   À²\€”À²Ñk/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. À²ÛÀ²è   À²ôƒ£À¶‹ƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   À¶›‚”À·ä0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. À·ìÀ·û  À¸
À¸  À¸
À¸   À¹3‡ÃÀÀË‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. ÀÀÛÀÀá  ÀÀî ÀÀú¥qÀÁ  ÀÁFI ÀÁnÀÁy%/// Create a new empty [Path] object.  ÀÁ“€£ÀÂ1ÀÂ2ÀÂ3€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].   ÀÃMÀÃ   ÀÃÀÃÀÃRJÀÃb  ÀÃkÀÃy  ÀÃRÀÃS1ÀÂ:VÀÂ   ÀÂ:ÀÂ;ÀÂAÀÂWÀÂGÀÂBÀÂOÀÂVÀÂPÀÂXÀÂoÀÂ_ÀÂYÀÂaÀÂ”jÀÂé  ÀÂğÀÂö  ÀÂ”ÀÂ•ÀÂ›ÀÂÀÀÂ¡ÀÂœÀÂ©ÀÂ¿ÀÂªÀÂ±ÀÂ¶ÀÂ²ÀÂ¹ÀÂÁÀÂ×ÀÂÈÀÂÂÀÂÊÀÃ pÀÄ   ÀÃ ÀÃ¡ÀÃ§ÀÃÅÀÃ®ÀÃ¨ÀÃ¶ÀÃÄÀÃ·ÀÃ¾ÀÃÃÀÃ¿ÀÃÆÀÃğÀÃÍÀÃÇÀÃÏÀÃêÀÃäÀÃìÀÄ€ƒÀÄ|  ÀÄ‰ÀÄ  ÀÄÀÄÀÄÀÄ?ÀÄ!ÀÄÀÄ)ÀÄ>ÀÄ*ÀÄ1ÀÄ6ÀÄ2ÀÄ9ÀÄ@ÀÄjÀÄGÀÄAÀÄIÀÄdÀÄ^ÀÄfÀÄ›€“ÀÅ  ÀÅÀÅ"  ÀÅ$ÀÅ,  ÀÄ›ÀÄœÀÄ§ÀÄ¨ÀÄ®ÀÄÛÀÄ´ÀÄ¯ÀÄ¼ÀÄÚÀÄ½ÀÄÄÀÄÉÀÄÅÀÄÌÀÄÔÀÄÜÀÅÀÄãÀÄİÀÄåÀÄûÀÄõÀÄıÀÅ2€¥ÀÅ²  ÀÅÁ	ÀÅÉ  ÀÅÌ	ÀÅÔ  ÀÅ2ÀÅ3ÀÅ>ÀÅ?ÀÅEÀÅrÀÅKÀÅFÀÅSÀÅqÀÅTÀÅ[ÀÅ`ÀÅ\ÀÅcÀÅkÀÅsÀÅ ÀÅzÀÅtÀÅ|ÀÅšÀÅ”ÀÅœÀÅÛ€“ÀÆS  ÀÆZÀÆb  ÀÆdÀÆl  ÀÅÛÀÅÜÀÅçÀÅèÀÅîÀÆÀÅôÀÅïÀÅüÀÆÀÅıÀÆÀÆ	ÀÆÀÆÀÆÀÆÀÆAÀÆ#ÀÆÀÆ%ÀÆ;ÀÆ5ÀÆ=ÀÆr€¥ÀÆò  ÀÇ	ÀÇ	  ÀÇ	ÀÇ  ÀÆrÀÆsÀÆ~ÀÆÀÆ…ÀÆ²ÀÆ‹ÀÆ†ÀÆ“ÀÆ±ÀÆ”ÀÆ›ÀÆ ÀÆœÀÆ£ÀÆ«ÀÆ³ÀÆàÀÆºÀÆ´ÀÆ¼ÀÆÚÀÆÔÀÆÜÀÇ€ÑÀÇ®  ÀÇÀ	ÀÇÈ  ÀÇË	ÀÇÓ  ÀÇÖ	ÀÇŞ  ÀÇá	ÀÇé  ÀÇÀÇÀÇ'ÀÇ(ÀÇ.ÀÇkÀÇ4ÀÇ/ÀÇ<ÀÇjÀÇ=ÀÇDÀÇIÀÇEÀÇLÀÇTÀÇ\ÀÇdÀÇlÀÇœÀÇsÀÇmÀÇuÀÇ–ÀÇÀÇ˜ÀÇğ€èÀÈ‹  ÀÈ¬	ÀÈ´  ÀÈ·	ÀÈ¿  ÀÈÂ	ÀÈÊ  ÀÈÍ	ÀÈÕ  ÀÇğÀÇñÀÇüÀÇıÀÈÀÈ@ÀÈ	ÀÈÀÈÀÈ?ÀÈÀÈÀÈÀÈÀÈ!ÀÈ)ÀÈ1ÀÈ9ÀÈAÀÈyÀÈHÀÈBÀÈJÀÈsÀÈmÀÈuÀÈÜ€ãÀÉu  ÀÉ}	ÀÉ…  ÀÉˆ	ÀÉ  ÀÉ“	ÀÉ›  ÀÉ	ÀÉ¦  ÀÉ©	ÀÉ±  ÀÉ´	ÀÉ¼  ÀÈÜÀÈİÀÈèÀÈéÀÈïÀÉ<ÀÈõÀÈğÀÈıÀÉ;ÀÈşÀÉÀÉ
ÀÉÀÉÀÉÀÉÀÉ%ÀÉ-ÀÉ5ÀÉ=ÀÉcÀÉDÀÉ>ÀÉFÀÉ]ÀÉWÀÉ_ÀÉÃ€óÀÊd  ÀÊt	ÀÊ|  ÀÊ	ÀÊ‡  ÀÊŠ	ÀÊ’  ÀÊ•	ÀÊ  ÀÊ 	ÀÊ¨  ÀÊ«	ÀÊ³  ÀÉÃÀÉÄÀÉÏÀÉĞÀÉÖÀÊ#ÀÉÜÀÉ×ÀÉäÀÊ"ÀÉåÀÉìÀÉñÀÉíÀÉôÀÉüÀÊÀÊÀÊÀÊÀÊ$ÀÊRÀÊ+ÀÊ%ÀÊ-ÀÊLÀÊFÀÊNÀÊº€ÏÀËK  ÀËS	ÀË[  ÀË^	ÀËf  ÀËi	ÀËq  ÀËt	ÀË|  ÀËÀË‡  ÀÊºÀÊ»ÀÊÆÀÊÇÀÊÍÀËÀÊÓÀÊÎÀÊÛÀËÀÊÜÀÊãÀÊèÀÊäÀÊëÀÊóÀÊûÀËÀËÀËÀË9ÀËÀËÀËÀË3ÀË-ÀË5ÀË€ßÀÌ&  ÀÌ6	ÀÌ>  ÀÌA	ÀÌI  ÀÌL	ÀÌT  ÀÌW	ÀÌ_  ÀÌbÀÌj  ÀËÀËÀË™ÀËšÀË ÀËåÀË¦ÀË¡ÀË®ÀËäÀË¯ÀË¶ÀË»ÀË·ÀË¾ÀËÆÀËÎÀËÖÀËŞÀËæÀÌÀËíÀËçÀËïÀÌÀÌÀÌÀÌp€ŞÀÌ  ÀÌ‡	ÀÌ  ÀÌ’ÀÌš  ÀÌ¥ÀÌ­  ÀÌ¸ÀÌ¾  ÀÌpÀÌqÀÍRÀÍã  ÀÍêÀÍò  ÀÍ÷
ÀÍÿ  ÀÎÀÎ  ÀÎÀÎ  ÀÎ ÀÎ(  ÀÎ3ÀÎ;  ÀÎFÀÎL  ÀÍRÀÍSÀÍYÀÍ¬ÀÍ_ÀÍZÀÍgÀÍ«ÀÍhÀÍoÀÍtÀÍpÀÍwÀÍÀÍ‡ÀÍÀÍ—ÀÍŸÀÍ§ÀÍ­ÀÍÑÀÍ´ÀÍ®ÀÍ¶ÀÍËÀÍÅÀÍÍÀÎ\KÀÎm  ÀÎxÀÎ€  ÀÎÀÎ•  ÀÎ®ÀÎ¶  ÀÎÉÀÎÏ  ÀÎäÀÎê  ÀÎ\ÀÎ]ÀÎÀÎ£ÀÎ¤ÀÎÀÀÎÙÀÎõÀÏ«ÀĞ?  ÀĞKÀĞS  ÀĞ[ÀĞc  ÀĞkÀĞs  ÀĞ{ÀĞƒ  ÀĞ‹ÀĞ“  ÀĞœÀĞ¢  ÀĞ«ÀĞ±  ÀÏ«ÀÏ¬ÀÏ²ÀĞÀÏ¸ÀÏ³ÀÏÀÀĞÀÏÁÀÏÈÀÏÍÀÏÉÀÏĞÀÏØÀÏàÀÏèÀÏğÀÏøÀÏşÀĞÀĞ-ÀĞÀĞÀĞÀĞ'ÀĞ!ÀĞ)ÀĞ¿tÀĞĞ  ÀĞèÀĞğ  ÀÑÀÑ
  ÀÑ#ÀÑ+  ÀÑ>ÀÑD  ÀÑYÀÑ_  ÀĞ¿ÀĞÀÀÑÀÑÀÑÀÑ5ÀÑNÀÑjÀÒ7KÀÒÓ  ÀÒîÀÒö  ÀÓÀÓ  ÀÓÀÓ"  ÀÓ0ÀÓ8  ÀÓFÀÓN  ÀÓ]ÀÓc  ÀÓrÀÓx  ÀÒ7ÀÒ8ÀÒ>ÀÒÀÒDÀÒ?ÀÒLÀÒÀÒMÀÒTÀÒYÀÒUÀÒ\ÀÒdÀÒlÀÒtÀÒ|ÀÒ„ÀÒŠÀÒÀÒÁÀÒ—ÀÒ‘ÀÒ™ÀÒ»ÀÒµÀÒ½ÀÓ†€…ÀÓ—  ÀÓŸ	ÀÓ¥  ÀÓ†ÀÓ‡ÀÔ€¼ÀÔŒ  ÀÔ•ÀÔ  ÀÔ¢
ÀÔª  ÀÔ®ÀÔ¶  ÀÔ¼ÀÔÄ  ÀÔÀÔÀÔÀÔSÀÔÀÔÀÔ$ÀÔRÀÔ%ÀÔ,ÀÔ1ÀÔ-ÀÔ4ÀÔ<ÀÔDÀÔLÀÔTÀÔzÀÔ[ÀÔUÀÔ]ÀÔtÀÔnÀÔvÀÔÏ€…ÀÔà  ÀÔè	ÀÔî  ÀÔÏÀÔĞÀÕX€¼ÀÕÕ  ÀÕŞÀÕæ  ÀÕë
ÀÕó  ÀÕ÷ÀÕÿ  ÀÖÀÖ  ÀÕXÀÕYÀÕ_ÀÕœÀÕeÀÕ`ÀÕmÀÕ›ÀÕnÀÕuÀÕzÀÕvÀÕ}ÀÕ…ÀÕÀÕ•ÀÕÀÕÃÀÕ¤ÀÕÀÕ¦ÀÕ½ÀÕ·ÀÕ¿ÀÖ€ÁÀÖ)  ÀÖ0	ÀÖ6  ÀÖ;ÀÖC  ÀÖNÀÖV  ÀÖÀÖÀÖİ€ğÀ×i  À×qÀ×y  À×~
À×†  À×ŠÀ×’  À×˜À×   À×§À×¯  À×ºÀ×Â  ÀÖİÀÖŞÀÖäÀ×1ÀÖêÀÖåÀÖòÀ×0ÀÖóÀÖúÀÖÿÀÖûÀ×À×
À×À×À×"À×*À×2À×WÀ×9À×3À×;À×QÀ×KÀ×SÀ×ÑtÀ×â  À×íÀ×û  ÀØ
ÀØ  À×ÑÀ×ÒÀØI€ŒÀØ©  ÀØµÀØÂ  ÀØÉ
ÀØÏ  ÀØIÀØJÀØPÀØ{ÀØVÀØQÀØ^ÀØzÀØ_ÀØfÀØkÀØgÀØnÀØvÀØ|ÀØ—ÀØƒÀØ}ÀØ…ÀØÙrÀØê  ÀØóÀØú  ÀØÙÀØÚÀÙOuÀÙ§  ÀÙ±ÀÙ¾  ÀÙOÀÙPÀÙVÀÙ{ÀÙ\ÀÙWÀÙdÀÙzÀÙeÀÙlÀÙqÀÙmÀÙtÀÙ|ÀÙ•ÀÙƒÀÙ}ÀÙ…ÀÙÈSÀÙÙ  ÀÙá	ÀÙç  ÀÙìÀÙô  ÀÙüÀÚ
  ÀÙÈÀÙÉÀÛ€ŸÀÛ  ÀÛ–ÀÛ£  ÀÛ¨	ÀÛ°  ÀÛ³	ÀÛ»  ÀÛÀÛ ÀÛ&ÀÛbÀÛ,ÀÛ'ÀÛ4ÀÛaÀÛ5ÀÛ<ÀÛAÀÛ=ÀÛDÀÛKÀÛPÀÛLÀÛSÀÛ[ÀÛcÀÛ{ÀÛjÀÛdÀÛlÀÛÂ€ÏÀÜB  ÀÜUÀÜb  ÀÜg	ÀÜo  ÀÜr	ÀÜz  ÀÜ}ÀÜŠ  ÀÛÂÀÛÃÀÛÉÀÜÀÛÏÀÛÊÀÛ×ÀÜÀÛØÀÛßÀÛäÀÛàÀÛçÀÛîÀÛóÀÛïÀÛöÀÛşÀÜÀÜÀÜ0ÀÜÀÜÀÜÀÜ•gÀÜ¦  ÀÜµ	ÀÜ»  ÀÜÀÀÜÈ  ÀÜĞÀÜŞ  ÀÜ•ÀÜ–ÀŞ €­ÀŞu  ÀŞ…ÀŞ’  ÀŞ—	ÀŞŸ  ÀŞ¢	ÀŞª  ÀŞ ÀŞÀŞÀŞCÀŞÀŞÀŞÀŞBÀŞÀŞÀŞ"ÀŞÀŞ%ÀŞ,ÀŞ1ÀŞ-ÀŞ4ÀŞ<ÀŞDÀŞcÀŞKÀŞEÀŞMÀŞ±€ÛÀß7  ÀßPÀß]  Àßb	Àßj  Àßm	Àßu  ÀßxÀß…  ÀŞ±ÀŞ²ÀŞ¸ÀŞüÀŞ¾ÀŞ¹ÀŞÆÀŞûÀŞÇÀŞÎÀŞÓÀŞÏÀŞÖÀŞİÀŞâÀŞŞÀŞåÀŞíÀŞõÀŞıÀß%ÀßÀŞşÀßÀßoÀß÷   ÀßÀß‘ÀßœÀßÀß£ÀßÀÀß©Àß¤Àß±Àß¿Àß²Àß¹Àß¾ÀßºÀßÁÀßåÀßÈÀßÂÀßÊÀßßÀßÙÀßáÀàoÀàj   ÀàÀàÀàÀàÀàÀà3ÀàÀàÀà$Àà2Àà%Àà,Àà1Àà-Àà4ÀàXÀà;Àà5Àà=ÀàRÀàLÀàTÀàvzÀà‡  ÀàÀà˜  ÀàvÀàwÀàô€ŒÀáb  ÀálÀát  ÀávÀá~  ÀàôÀàõÀàûÀá(ÀáÀàüÀá	Àá'Àá
ÀáÀáÀáÀáÀá!Àá)ÀáPÀá0Àá*Àá2ÀáJÀáDÀáLÀá„€¶Àá•  Àá›Àá£  Àá„Àá…Àâ>€Àâ£  ÀâªÀâ°  Àâ¸	ÀâÀ  ÀâÃ	ÀâË  Àâ>Àâ?ÀâEÀâzÀâKÀâFÀâSÀâyÀâTÀâ[Àâ`Àâ\ÀâcÀâkÀâsÀâ{Àâ‘Àâ‚Àâ|Àâ„ÀâÒ€¹Àâã  ÀâíÀâú  ÀâÒÀâÓÀã€Àãğ  ÀãûÀä  Àä	Àä  ÀãÀãÀã–ÀãÃÀãœÀã—Àã¤ÀãÂÀã¥Àã¬Àã±Àã­Àã´Àã¼ÀãÄÀãŞÀãËÀãÅÀãÍÀä"€‹Àä3   Àä"Àä#Àä±gÀå   Àä±Àä²Àä¸Àä×ÀäÀÀä¹ÀäÈÀäÖÀäÉÀäĞÀäÕÀäÑÀäØÀäòÀäßÀäÙÀäáÀå€¨Àå‹  ÀåÀåœ  Àå¢Àå¯  ÀåµÀåº  ÀåÀåÀå#ÀåeÀå)Àå$Àå1ÀådÀå2Àå9Àå>Àå:ÀåAÀåHÀåMÀåIÀåPÀåWÀå\ÀåXÀå_ÀåfÀåyÀåmÀågÀåoÀåÈuÀåà  ÀåğÀåö  ÀåÈÀåÉÀæÀæA(ÀæT   ÀæAÀæB Àæm‡DÀç%€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. Àç1€‡ Àç”Àç›V/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.ÀçœÀç¢  Àç«Àç±   Àç¼RÀè—Àè˜Àè¡€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.Àè¢Àèª  Àè³Àè»   Àé€ÑÀéÛ€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. ÀéèÀêç€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). Àêò‚½Àí„‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     Àí³„#Àğ®‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. Àğê€‚ÀğõÀğöÀğ÷ Àğø	Àğş  ÀñÀñ	  Àñ%ÀñÀñ'Àñ9Àñ:Àñ;ÀñjÀñ<ÀñHÀñiÀñNÀñIÀñQÀñ^Àñp$Àñ‹  Àñ™;Àñ¾   Àñ™Àñš  ÀñØƒÂÀòGh/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. Àò~(ÀòÀò‘Àò’ Àò“Àò™   ÀòªÀò¶  ÀòÅÀòØ  ÀòéğÀó   ÀòéÀòêÀôİ€»Àôî   ÀôİÀôŞ ÀõœkÀøƒ‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. Àø’€ÎÀøœÀøÀø ÀøŸÀø¥  Àø»Àø´Àø½ÀøÅÀøÆÀøÌÀøéÀøÍÀøÕÀøÖÀøûÀøòÀøıÀùÀùÀùÀù+ÀùÀùÀùÀùAÀù4ÀùCÀùKÀùLÀùd+Àú‰/// Return the total length of the current contour.
///
/// The length may be calculated from an approximation of the geometry
/// originally added. For this reason, it is not recommended to rely on
/// this property for mathematically correct lengths of common shapes. Àú”AÀûÍ!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. ÀûÚ‚àÀş®‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. Àş¿ÀşÒ   Àşß‚,À  £/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. À ´À ¼   ÀÀé€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. ÀõÀı  À
À  ÀÀ  À'À”qÀ§   À”À• À	‹À  ÀF[ ÀFÀR ÀSÀ`  ÀeÀk   Àn€¯À€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.ÀÀ À¥€”À  ÀÀ"  À'À-  À¥À¦À¬À×À²À­ÀºÀÖÀ»ÀÃÀÊÀÏÀËÀÒÀØÀöÀßÀÙÀáÀ=€½ÀD  ÀKÀP   Àş€‹Ào  ÀwÀ|  ÀşÀÿÀÀ+ÀÀÀÀ*ÀÀÀ"ÀÀ%À,À[À3À-À5ÀUÀOÀWÀíÀ–  ÀªÀ¯  À¼ÀÄ   À~€Àî  ÀùÀş  ÀÀ  À~ÀÀ…À³ÀÀ†À•À²À–ÀÀ¢ÀÀ¥À¬À´ÀÕÀ»ÀµÀ½À _À%  À1À6  ÀCÀK  ÀQ
ÀY  ÀdÀj  À{À	ƒ€ÛÀ
  À
À
  À
À
!  À
.À
6  À
<
À
D  À
HÀ
N  À	ƒÀ	„À	ŠÀ	ÌÀ	À	‹À	˜À	ËÀ	™À	 À	¥À	¡À	¨À	°À	·À	¿À	ÇÀ	ÍÀ	ïÀ	ÔÀ	ÎÀ	ÖÀ
b€¿À
g  À
pÀ
u   À%€ˆÀ‘  À›À   À%À&À,ÀPÀ2À-À:ÀOÀ;ÀBÀGÀCÀJÀQÀÀXÀRÀZÀyÀsÀ{À`€‰Àe    Àí}ÀU   ÀíÀîÀôÀÀúÀõÀÀÀÀ
ÀÀÀÀCÀÀÀÀ=À7À? ÀŸ†|À©/// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. À¸ƒÀ’À“À—‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.ÀÀ£  À®À´   ÀÃÀÓ  ÀİÀê  À†À— À£À°ÀÁ ÀÍÀ<À“   ÀÀ€Àç€”À  ÀÀ  ÀçÀèÀ¿ZÀÒ   À¿ÀÀ À™kÀèÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. À‚XÀÔÀÕÀÙ¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.ÀÚÀá  ÀçÀò  ÀÀÀÀ'ÀÀ)ÀDÀ<ÀFÀZÀTÀ\ÀkˆEÀ$*À$+À$1‡7/// Construct a color filter from a 4x5 row-major matrix. The matrix is
/// interpreted as a 5x5 matrix, where the fifth row is the identity
/// configuration.
///
/// Every pixel's color value, represented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
///     | R' |   | a00 a01 a02 a03 a04 |   | R |
///     | G' |   | a10 a11 a12 a13 a14 |   | G |
///     | B' | = | a20 a21 a22 a23 a24 | * | B |
///     | A' |   | a30 a31 a32 a33 a34 |   | A |
///     | 1  |   |  0   0   0   0   1  |   | 1 |
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```dart
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```dart
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```dart
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```dart
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```À$2À$@  À$VÀ$OÀ$XÀ$qÀ$fÀ$sÀ$‰À$À$‹À$¡À$›À$£À$´€ôÀ%!À%"À%3W/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. À%EÀ%>À%GÀ%`À%UÀ%bÀ%xÀ%pÀ%zÀ%À%ˆÀ%À%¬À&&À&'À&8d/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. À&JÀ&CÀ&LÀ&eÀ&ZÀ&gÀ&}À&uÀ&À&“À&À&•À&±À&¾  À&ÈÀ&Ù  À&çÀ&û  À'À'  À'JÀ'[ À'hÀ'!À' À'ŸÀ'Ã,À'Ô À'îÀ(,À( À(7À,á€¯À,õ   À,áÀ,âÀ-”ÁÀ-«   À-”À-•À(nVÀ(‡   À(nÀ(oÀ(È‚×À(Ö    À+£:À+½  À+ÀÀ+È  À+£À+¤À/Y‚-À/l   À/YÀ/Z À1Š‡jÀ2ÚD/// A [ColorFilter] that is backed by a native DlColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. À3€°À3À3À3 À3À3$  
À32À38À3`À3GÀ39À3@À3AÀ3JÀ3UÀ3VÀ3À€¬À3ÌÀ3ÍÀ3Ó À3ÔÀ3Ú  
À3èÀ3îÀ4À3ıÀ3ïÀ3öÀ3÷À4 À4À4À4o€§À4{À4|À4 À4À4”  
À4¢À4¨À4İÀ4·À4©À4°À4±À4ºÀ4ÅÀ4ÆÀ5€§À5&À5'À58 À59À5?  
À5MÀ5SÀ5ˆÀ5bÀ5TÀ5[À5\À5eÀ5pÀ5qÀ5Å€À6Ko/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À6W]À6¥   À6WÀ6XÀ6^À6tÀ6dÀ6_À6lÀ6sÀ6mÀ6uÀ6“À6|À6vÀ6~À6¸€—À7+  À75	À7:  À7@À7E  À6¸À6¹À6¿À6êÀ6ÅÀ6ÀÀ6ÍÀ6éÀ6ÎÀ6ÕÀ6ÚÀ6ÖÀ6İÀ6äÀ6ëÀ7À6òÀ6ìÀ6ôÀ7À7À7À7S€À7´  À7ÀÀ7Í  À7SÀ7TÀ7ZÀ7À7`À7[À7hÀ7~À7iÀ7pÀ7uÀ7qÀ7xÀ7€À7¢À7‡À7À7‰À7Ø€‹À8J   À7ØÀ7ÙÀ7ßÀ7üÀ7åÀ7àÀ7íÀ7ûÀ7îÀ7õÀ7úÀ7öÀ7ıÀ88À8À7şÀ8À82À8,À84À8g€‹À8Ù   À8gÀ8hÀ8nÀ8‹À8tÀ8oÀ8|À8ŠÀ8}À8„À8‰À8…À8ŒÀ8ÇÀ8“À8À8•À8ÁÀ8»À8Ã À8ö‹À:ØÒ/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. À;:À;EÀ;FÀ;G   À;hÀ;·À;¸À;¼9/// Creates an image filter that applies a Gaussian blur.À;¿À;Ç  À;ÔÀ;Ü  À;é"À;ó  À;ÏÀ;äÀ;ıÀ<À<À<q&À=À=À=€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.À=!À=)  À=7À=?  À=2À=HÀ=›'À>DÀ>EÀ>J€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À>MÀ>U  À>cÀ>k  À>^À>tÀ>Æ‚'À?»À?¼À?Â€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.À?ÃÀ?Ğ  À?ï/À?ş  À@À@À@À@ñ ÀAÿÀB ÀB€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).ÀB
ÀB   ÀB&ÀB<    ÀCÜÀCç    ÀC3$ÀC@     ÀCıƒ`ÀD  ÀD1H ÀD1ÀDC ÀDFÀDU  ÀDZÀDi   ÀD}ÀD  ÀD—!ÀD«  ÀDŞ@ÀDö ÀEÀEÀEÀEÀEÀEÀEfLÀE}   ÀEfÀEgÀG
QÀG   ÀG
ÀGÀE"@ÀE;   ÀE"ÀE#ÀE¶MÀEÉ   ÀE¶ÀE·ÀF€ÿÀF!  ÀF$ÀF,  ÀFÀF ÀG_„tÀGe  ÀG™a ÀG™ÀG± ÀG´ÀGÃ  ÀGÊÀGÙ  ÀGàÀGï   ÀGşÀH  ÀHÀH"  ÀH,ÀH;  ÀH\>ÀHt ÀHƒÀHÀHÀH”ÀH™ÀH•ÀHâ€îÀHí    ÀIÔSÀIë   ÀIÔÀIÕÀK•<ÀK©   ÀK•ÀK–ÀH@ÀH·   ÀHÀHŸÀJ+TÀJ>   ÀJ+ÀJ,ÀJƒÀJ  ÀJ ÀJ¨  ÀJƒÀJ„ ÀKÕ‚ûÀKÛ  ÀL	E ÀL	ÀL ÀLÀL-  ÀL5ÀLD   ÀLRÀL_  ÀLjÀLw  ÀLƒ@ÀL› ÀLªÀL¶ÀL·ÀL½ÀLÂÀL¾ÀMIÀM"   ÀMÀMÀN>ÀN¤   ÀNÀN‘ÀLÇ@ÀLà   ÀLÇÀLÈÀMXJÀMk   ÀMXÀMYÀM¦€æÀMÀ  ÀMÃÀMË  ÀM¦ÀM§ ÀNÒ‚õÀNØ  ÀOD ÀOÀO ÀOÀO(  ÀO0ÀO?   ÀOMÀOZ  ÀOeÀOr  ÀO~?ÀO– ÀO¥ÀO±ÀO²ÀO·ÀO¼ÀO¸ÀPHÀP   ÀPÀPÀQ‡>ÀQ›   ÀQ‡ÀQˆÀOÁ@ÀOÚ   ÀOÁÀOÂÀPQIÀPd   ÀPQÀPRÀP€åÀP¸  ÀP»ÀPÃ  ÀPÀPŸ ÀQÉƒ‹ÀQÏ  ÀQşN ÀQşÀR ÀRÀR#  ÀR/ÀR>   ÀRPÀRb  ÀRqÀRƒ  ÀR­BÀRÅ ÀRÔÀRàÀRáÀRéÀRîÀRêÀS7sÀSN   ÀS7ÀS8ÀUFÀU    ÀUÀUÀRó@ÀS   ÀRóÀRôÀS®_ÀSÁ   ÀS®ÀS¯ÀT€÷ÀT+  ÀT.ÀT6  ÀTÀT ÀUVöÀV‹)/// An [ImageFilter] that is backed by a native DlImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. ÀV½€ãÀWÀWÀW
9/// Creates an image filter that applies a Gaussian blur.ÀWÀW%  ÀW:ÀW2ÀW<ÀW¤#ÀXCÀXDÀXJ€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.ÀXKÀX_  ÀXtÀXlÀXvÀXË#ÀYmÀYnÀYs€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.ÀYtÀY‡  ÀYœÀY”ÀYÀYòãÀZàÀZáÀZç€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀZèÀZü  À[À[	À[À[Ù€ıÀ\À\À\'//// Converts a color filter to an image filter.À\(À\5  À\JÀ\BÀ\LÀ\ÚzÀ]À]À]"0/// Composes `_innerFilter` with `_outerFilter`.À]#À]8  À]MÀ]EÀ]OÀb¼€ÀcBo/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À^X]À^¦   À^XÀ^YÀ^_À^uÀ^eÀ^`À^mÀ^tÀ^nÀ^vÀ^”À^}À^wÀ^À^¹€²À_5  À_?À_G  À_NÀ_V  À_]À_b  À^¹À^ºÀ^ÀÀ^ôÀ^ÆÀ^ÁÀ^ÎÀ^óÀ^ÏÀ^ÖÀ^ÛÀ^×À^ŞÀ^æÀ^îÀ^õÀ_#À^üÀ^öÀ^şÀ_À_À_À_o€£À_æ  À_òÀ_ú  À`À`
  À_oÀ_pÀ_vÀ_£À_|À_wÀ_„À_¢À_…À_ŒÀ_‘À_À_”À_œÀ_¤À_ÔÀ_«À_¥À_­À_ÎÀ_ÈÀ_ĞÀ`€¡À`Œ  À`—À`Ÿ  À`§À`¯  À`À`À`À`JÀ`#À`À`+À`IÀ`,À`3À`8À`4À`;À`CÀ`KÀ`zÀ`RÀ`LÀ`TÀ`tÀ`nÀ`vÀ`»€œÀa#  Àa/Àa<  ÀaDÀaI  À`»À`¼À`ÂÀ`îÀ`ÈÀ`ÃÀ`ĞÀ`íÀ`ÑÀ`ØÀ`İÀ`ÙÀ`àÀ`èÀ`ïÀaÀ`öÀ`ğÀ`øÀa[€™ÀaÈ  ÀaÙÀaè  Àa[Àa\ÀabÀaÀahÀacÀapÀaÀaqÀaxÀa}ÀayÀa€Àa‡ÀaŒÀaˆÀaÀa¶Àa–ÀaÀa˜Àaø€ÀÀbv  Àb„Àb’  ÀbÀb¬  ÀaøÀaùÀaÿÀb:ÀbÀb ÀbÀb9ÀbÀbÀbÀbÀbÀb$Àb)Àb%Àb,Àb3Àb8Àb4Àb;ÀbdÀbBÀb<ÀbD ÀcN„ëÀcÔz/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. Àd €ÀdˆÀd‰ÀdŠa/// This class is created by the engine, and should not be instantiated
/// or extended directly. ÀdfÀdgÀdmÀd~ÀdnÀd‘Àd– Àd§Àd±Àe:y/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀeÌ‚kÀg¿Û/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, a [Picture] that has not been disposed that
/// refers to an [ImageShader] may keep its underlying resources alive.
///
/// Classes that override this method must call `super.dispose()`.    À~ğ©À€<@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// À€X‰À†¡À†¢À†¨†/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À†®À†¶  À†¿	À†Ç  À†ÎÀ†Û  À†èÀ†÷  À‡"À‡  À‡.À‡<  !À‡À‡"À‡#À‡KÀ‡QÀ‡fÀ‡RÀ‡`À‡eÀ‡aÀ‡pÀ‡vÀ‡‰À‡wÀ‡…À‡ˆÀ‡†À‡“À‡™À‡ÅÀ‡ªÀ‡¢À‡šÀ‡¥À‡­À‡¼À‡ÄÀ‡½À‡ÏÀ‡ÔÀ‡ÕÀ‡ÖÀ‡×À‰gŒøÀ‘—À‘˜À‘‡ã/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].À‘¤À‘¬  À‘·À‘¿  À‘ÊÀ‘×  À‘äÀ‘ó  À’"À’  À’*À’8  À’DÀ’M  À’WÀ’_  À’À’À’À’lÀ’wÀ’}À’”À’~À’ŒÀ’“À’À’À’¤À’ĞÀ’µÀ’­À’¥À’°À’¸À’ÇÀ’ÏÀ’ÈÀ’ÚÀ’ßÀ’àÀ’áÀ’âÀ–cŠIÀİÀŞÀã‡3/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries). Stop values less than 0.0
/// will be rounded up to 0.0 and stop values greater than 1.0 will be rounded
/// down to 1.0. Each stop value must be greater than or equal to the previous
/// stop value. Stop values that do not meet this criteria will be rounded up
/// to the previous stop value.
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.ÀéÀñ  ÀüÀ	  ÀÀ%  À4"À>  À\Àd  ÀyÀ  ÀœÀª  &ÀHÀPÀQÀpÀ“À‹ÀÀÀ•À¹À¿ÀÖÀÀÀÎÀÕÀÏÀàÀæÀüÀòÀçÀôÀŸÀŸÀŸ8ÀŸÀŸÀŸÀŸÀŸ ÀŸ/ÀŸ7ÀŸ0ÀŸBÀŸGÀŸHÀŸIÀŸJ  À °ZÀ û   À °À ±À ·À ÍÀ ½À ¸À ÅÀ ÌÀ ÆÀ ÎÀ éÀ ÕÀ ÏÀ ×À¡€ïÀ¡‹  À¡—À¡¤  À¡®À¡¹  À¡ÀÀ¡Î  À¡ÙÀ¡Ş  À¡çÀ¡õ  À¡À¡À¡À¡YÀ¡À¡À¡#À¡XÀ¡$À¡+À¡0À¡,À¡3À¡;À¡CÀ¡KÀ¡RÀ¡ZÀ¡yÀ¡aÀ¡[À¡cÀ¢BÀ¢  À¢¡À¢©  À¢·À¢¿  À¢ÍÀ¢Õ  À¢âÀ¢í  À¢úÀ£  À£À£  À£-À£;  À¢À¢À¢À¢\À¢À¢	À¢À¢[À¢À¢À¢#À¢À¢&À¢.À¢6À¢>À¢FÀ¢NÀ¢UÀ¢]À¢|À¢dÀ¢^À¢fÀ£G¥À£õ  
À¤	À¤  À¤À¤&  À¤3À¤;  À¤MÀ¤U  À¤`À¤h  À¤sÀ¤{  À¤‹À¤–  À¤£À¤±  À¤ÂÀ¤Ç  À¤ÖÀ¤ä  À£GÀ£HÀ£NÀ£ºÀ£TÀ£OÀ£\À£¹À£]À£dÀ£iÀ£eÀ£lÀ£tÀ£|À£„À£ŒÀ£”À£œÀ£¤À£¬À£³À£»À£ãÀ£ÂÀ£¼À£ÄÀ¤ğbÀ¥„  À¥–À¥  À¥¬À¥´  À¥ÂÀ¥Í  À¥ÚÀ¥è  À¥ùÀ¥ş  À¦À¦  À¦&À¦.  À¦=À¦K  À¤ğÀ¤ñÀ¤÷À¥SÀ¤ıÀ¤øÀ¥À¥RÀ¥À¥À¥À¥À¥À¥À¥%À¥-À¥5À¥<À¥DÀ¥LÀ¥TÀ¥rÀ¥[À¥UÀ¥]À¦VŸÀ¦b  À¦}À¦Š  À¦‘À¦     À§ùˆlÀ¨B=/// A shader (as used by [Paint.shader]) that tiles an image. À¨a…– À¬%À¬0ƒ/// Creates an image-tiling shader.
///
/// The first argument specifies the image to render. The
/// [decodeImageFromList] function can be used to decode an image from bytes
/// into the form expected here. (In production code, starting from
/// [instantiateImageCodec] may be preferable.)
///
/// The second and third arguments specify the [TileMode] for the x direction
/// and y direction respectively. [TileMode.repeated] can be used for tiling
/// images.
///
/// The fourth argument gives the matrix to apply to the effect. The
/// expression `Matrix4.identity().storage` creates a [Float64List]
/// prepopulated with the identity matrix.
///
/// All the arguments are required and must not be null, except for
/// [filterQuality]. If [filterQuality] is not specified at construction time
/// it will be deduced from the environment where it is used, such as from
/// [Paint.filterQuality].À¬1À¬8  À¬>À¬H  À¬LÀ¬V  À¬ZÀ¬g  À¬uÀ¬…  À¬	À¬
À¬À¬!À¬À¬À¬¤À¬¹À¬¥À¬¦À¬«À¬¬À¬ÀÀ¬ÅÀ¬ÆÀ¬ÇÀ¬È  À­ûEÀ®   À­ûÀ­üÀ®D]À®’   À®DÀ®EÀ®KÀ®aÀ®QÀ®LÀ®YÀ®`À®ZÀ®bÀ®€À®iÀ®cÀ®kÀ®¥€éÀ¯2  À¯AÀ¯I  À¯OÀ¯T  À¯XÀ¯]  À¯aÀ¯f  À¯yÀ¯†  À®¥À®¦À®¬À®÷À®´À®­À®¼À®öÀ®½À®ÄÀ®ÉÀ®ÅÀ®ÌÀ®ÓÀ®ØÀ®ÔÀ®ÛÀ®âÀ®éÀ®ğÀ®øÀ¯À®ÿÀ®ùÀ¯À¯’€ÑÀ°Xk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À°À°À°	À°&À°À°
À°À°%À°À°À°$À° À°'À°FÀ°.À°(À°0 À°gŒeÀ±O€Ü/// An instance of [FragmentProgram] creates [Shader] objects (as used by
/// [Paint.shader]).
///
/// For more information, see the website
/// [documentation]( https://docs.flutter.dev/development/ui/advanced/shaders). À±„!À±¯À±°À±º À±»À±Ã  À±„À±…À±‹À±œÀ±ŒÀ²©À²±  À¸|]À¸¦ À¸×À¸ØÀ¸¾À¸ÖÀ¸¿À¸ÇÀºİ7À» ÀºİÀºŞÀºäÀºõÀºåÀ»2À»> À»À»À» À»1À»! À²À„+À´//// Creates a fragment program from the asset with key [assetKey].
///
/// The asset must be a file produced as the output of the `impellerc`
/// compiler. The constructed object should then be reused via the
/// [fragmentShader] method to create [Shader] objects that can be used by
/// [Paint.shader]. À´%À´-   À¸ŞûÀ¸ê  À¸şÀ¹   À»PaÀ»¢   À»PÀ»QÀ»WÀ»mÀ»]À»XÀ»eÀ»lÀ»fÀ»nÀ»À»uÀ»oÀ»wÀ»µ€ŒÀ¼!  À¼0À¼8  À»µÀ»¶À»¼À»ãÀ»ÄÀ»½À»ÌÀ»âÀ»ÍÀ»ÔÀ»ÙÀ»ÕÀ»ÜÀ»äÀ¼À»ëÀ»åÀ»íÀ¼E€…À¼ˆ1/// Returns a fresh instance of [FragmentShader].    À¼Î‘şÀ¿¿‚å/// A [Shader] generated from a [FragmentProgram].
///
/// Instances of this class can be obtained from the
/// [FragmentProgram.fragmentShader] method. The float uniforms list is
/// initialized to the size expected by the shader and is zero-filled. Uniforms
/// of float type can then be set by calling [setFloat]. Sampler uniforms are
/// set by calling [setImageSampler].
///
/// A [FragmentShader] can be re-used, and this is an efficient way to avoid
/// allocating and re-initializing the uniform buffer and samplers. However,
/// if two [FragmentShader] objects with different float uniforms or samplers
/// are required to exist simultaneously, they must be obtained from two
/// different calls to [FragmentProgram.fragmentShader]. À¿á€ÛÀ¿ïÀ¿ğÀ¿ñ À¿òÀÀ  ÀÀÀÀ  ÀÀ/ÀÀ$ÀÀ1ÀÀ<ÀÀAÀÀBÀÀCÀÀDÀÀÀÀÀÎ  ÀÀİ<ÀÀö ÀÁÀÁÀÁÀÁÀÁ(ÀÁ) ÀÁ3 ÀÁJ‡ÀÈB†œ/// Sets the float uniform at [index] to [value].
///
/// All uniforms defined in a fragment shader that are not samplers must be
/// set through this method. This includes floats and vec2, vec3, and vec4.
/// The correct index for each uniform is determined by the order of the
/// uniforms as defined in the fragment program, ignoring any samplers. For
/// data types that are composed of multiple floats such as a vec4, more than
/// one call to [setFloat] is required.
///
/// For example, given the following uniforms in a fragment program:
///
/// ```glsl
/// uniform float uScale;
/// uniform sampler2D uTexture;
/// uniform vec2 uMagnitude;
/// uniform vec4 uColor;
/// ```
///
/// Then the corresponding Dart code to correctly initialize these uniforms
/// is:
///
/// ```dart
/// void updateShader(ui.FragmentShader shader, Color color, ui.Image image) {
///   shader.setFloat(0, 23);  // uScale
///   shader.setFloat(1, 114); // uMagnitude x
///   shader.setFloat(2, 83);  // uMagnitude y
///
///   // Convert color to premultiplied opacity.
///   shader.setFloat(3, color.red / 255 * color.opacity);   // uColor r
///   shader.setFloat(4, color.green / 255 * color.opacity); // uColor g
///   shader.setFloat(5, color.blue / 255 * color.opacity);  // uColor b
///   shader.setFloat(6, color.opacity);                     // uColor a
///
///   // initialize sampler uniform.
///   shader.setImageSampler(0, image);
/// }
/// ```
///
/// Note how the indexes used does not count the `sampler2D` uniform. This
/// uniform will be set separately with [setImageSampler], with the index starting
/// over at 0.
///
/// Any float uniforms that are left uninitialized will default to `0`. ÀÈK	ÀÈP  ÀÈVÀÈ^   ÀÈŞüÀÊ.</// Sets the sampler uniform at [index] to [image].
///
/// The index provided to setImageSampler is the index of the sampler uniform defined
/// in the fragment program, excluding all non-sampler uniforms.
///
/// All the sampler uniforms that a shader expects must be provided or the
/// results will be undefined. ÀÊ>	ÀÊC  ÀÊIÀÊP   ÀÊŞ…ÀÌ/// Releases the native resources held by the [FragmentShader].
///
/// After this method is called, calling methods on the shader, or attaching
/// it to a [Paint] object will fail with an exception. Calling [dispose]
/// twice will also result in an exception being thrown.  ÀËüÀËıÀÌg€ÈÀÌá  ÀÌîÀÌÿ  ÀÍÀÍ  ÀÍÀÍ  ÀÌgÀÌhÀÌnÀÌÀÌvÀÌoÀÌ~ÀÌÀÌÀÌ‡ÀÌÀÌ—ÀÌŸÀÌÈÀÌ¦ÀÌ ÀÌ¨ÀÍ3€¥ÀÍ¬  ÀÍ½	ÀÍÂ  ÀÍÈÀÍĞ  ÀÍ3ÀÍ4ÀÍ:ÀÍgÀÍ@ÀÍ;ÀÍHÀÍfÀÍIÀÍPÀÍUÀÍQÀÍXÀÍ`ÀÍhÀÍšÀÍoÀÍiÀÍqÀÍÜ~ÀÎF   ÀÍÜÀÍİÀÍãÀÎ ÀÍéÀÍäÀÍñÀÍÿÀÍòÀÍùÀÍşÀÍúÀÎÀÎ4ÀÎÀÎÀÎ
ÀÎ^lÀÎ¿   ÀÎ^ÀÎ_ÀÎeÀÎ‚ÀÎkÀÎfÀÎsÀÎÀÎtÀÎ{ÀÎ€ÀÎ|ÀÎƒÀÎ­ÀÎŠÀÎ„ÀÎŒ ÀÑ“¬ÀÚˆn/// A set of vertex data used by [Canvas.drawVertices].
///
/// Vertex data consists of a series of points in the canvas coordinate space.
/// Based on the [VertexMode], these points are interpreted either as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single shared
/// point ([VertexMode.triangleFan]).
///
/// Each point can be associated with a color. Each triangle is painted as a
/// gradient that blends between the three colors at the three points of that
/// triangle. If no colors are specified, transparent black is assumed for all
/// the points.
///
/// These colors are then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices]. This paint is either a solid color ([Paint.color]),
/// or a bitmap, specified using a shader ([Paint.shader]), typically either a
/// gradient ([Gradient]) or image ([ImageFilter]). The bitmap uses the same
/// coordinate space as the canvas (in the case of an [ImageFilter], this is
/// notably different than the coordinate space of the source image; the source
/// image is tiled according to the filter's configuration, and the image that
/// is sampled when painting the triangles is the infinite one after all the
/// repeating is applied.)
///
/// Each point in the [Vertices] is associated with a specific point on this
/// image. Each triangle is painted by sampling points from this image by
/// interpolating between the three points of the image corresponding to the
/// three points of the triangle.
///
/// The [Vertices.new] constructor configures all this using lists of [Offset]
/// and [Color] objects. The [Vertices.raw] constructor instead uses
/// [Float32List], [Int32List], and [Uint16List] objects, which more closely
/// corresponds to the data format used internally and therefore reduces some of
/// the conversion overhead. The raw constructor is useful if the data is coming
/// from another source (e.g. a file) and can therefore be parsed directly into
/// the underlying representation. ÀÚ;é Àã<ÀãDˆ¬/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles.
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each triangle is painted as a gradient that blends between
/// the three colors at the three points of that triangle. (These colors are
/// then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
///
/// If the `colors` or `textureCoordinates` parameters are specified, they must
/// be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-1, where _n_ is the number of entries in `positions`. The
/// `indices` parameter, if present and non-empty, must have at least three
/// entries, but may be of any length beyond this. Indicies may refer to
/// offsets in the positions array multiple times, or may skip positions
/// entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for `positions`.
///
/// The `mode` and `positions` parameters must not be null.
///
/// This constructor converts its parameters into [dart:typed_data] lists
/// (e.g. using [Float32List]s for the coordinates) before sending them to the
/// Flutter engine. If the data provided to this constructor is not already in
/// [List] form, consider using the [Vertices.raw] constructor instead to
/// avoid converting the data twice.ÀãJÀãV  Àã_Àãm  Àã}Àã‹  Àã– Àã¥  Àã¼ÀãÈ   Àé(WÀó±Àó²ÀóµŠ(/// Creates a set of vertex data for use with [Canvas.drawVertices], using the
/// encoding expected by the Flutter engine.
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles. Each point is represented as two
/// numbers in the list, the first giving the x coordinate and the second
/// giving the y coordinate. (As a result, the list must have an even number
/// of entries.)
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each color is represented as ARGB with 8 bit color channels
/// (like [Color.value]'s internal representation), and the list, if
/// specified, must therefore be half the length of `positions`. Each triangle
/// is painted as a gradient that blends between the three colors at the three
/// points of that triangle. (These colors are then blended with the [Paint]
/// specified in the call to [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
/// Each point is represented as two numbers in the list, the first giving the
/// x coordinate and the second giving the y coordinate. This list, if
/// specified, must be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-2, where _n_ is the number of pairs in `positions` (i.e. half
/// the length of `positions`). The `indices` parameter, if present and
/// non-empty, must have at least three entries, but may be of any length
/// beyond this. Indicies may refer to offsets in the positions array multiple
/// times, or may skip positions entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for pairs in `positions`. For example, if there are 12
/// numbers in `positions` (representing 6 coordinates), the `indicies` must
/// be numbers in the range 0..5 inclusive.
///
/// The `mode` and `positions` parameters must not be null.Àó»ÀóÇ  ÀóĞÀóİ  ÀóíÀóù  ÀôÀô  Àô)Àô6   ÀûßÀûä ÀûğÀûùÀü¶€«/// Whether this reference to the underlying vertex data is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀøƒÀøú  Àù Àù
  Àù3Àù8  ÀùZÀùg  ÀùÀùœ  ÀùÌÀùØ  ÀùüÀú	  ÀøƒÀø„ÀøŠÀøÇÀøÀø‹Àø˜ÀøÆÀø™Àø¡Àø¨Àø°Àø¸ÀøÀÀøÈÀøáÀøÏÀøÉÀøÑÀú€ôÀún/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   Àû€ÎÀûĞk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  Àû}Àû~Àû„Àû¡ÀûŠÀû…Àû’Àû Àû“ÀûšÀûŸÀû›Àû¢Àû¾Àû©Àû£Àû« ÀáÀ –2ÀZƒi/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods. Àe‚× À÷Àı‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.ÀşÀ	  À	À	!     %À	@(À
a/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   À
l”šÀá“•/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. ÀëÀò  ÀùÀ    À
FÀ F(/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   À T‚%À"_ó/// Restores the save stack to a previous level as might be obtained from [getSaveCount].
/// If [count] is less than 1, the stack is restored to its initial state.
/// If [count] is greater than the current [getSaveCount] then nothing happens.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If any of the state stack levels restored by this call were pushed with
/// [saveLayer], then this call will also cause those layers to be composited
/// into their previous layers. À"n	À"s   À"}BÀ#°"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   À#Ã€ÅÀ$h€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. À$r	À$z  À$}	À$…   À$Œ,À%™€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. À%Ÿ	À%§  À%«
À%´   À%¼qÀ&R/// Add a rotation to the current transform. The argument is in radians clockwise. À&À&%   À&15À'K/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. À'P	À'X  À'[	À'c   À'j€¯À'ú€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. À(À(   À(‚À*×/// Returns the current transform including the combined result of all transform
/// methods executed since the creation of this [Canvas] object, and respecting the
/// save/restore history.
///
/// Methods that can change the current transform include [translate], [scale],
/// [rotate], [skew], and [transform]. The [restore] method can also modify
/// the current transform by restoring it to the same value it had before its
/// associated [save] or [saveLayer] call.   À*$‚À,a‚/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. À,j	À,p  À,w À,  À,™À,Ÿ  À,‡À,À,À,¬À,¸‚;À.Áï/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rrect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. À.ËÀ.Ò  À.ÙÀ.ß  À.ìÀ.÷‚À0Í¼/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_path.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. À0Ö	À0Ü  À0âÀ0è  À0õÀ1 ŠİÀ;ÈŠZ/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the local coordinate space under which rendering operations are currently
/// performed.
///
/// The combined clip results are rounded out to an integer pixel boundary before
/// they are transformed back into the local coordinate space which accounts for
/// the pixel roundoff in rendering operations, particularly when antialiasing.
/// Because the [Picture] may eventually be rendered into a scene within the
/// context of transforming widgets or layers, the result may thus be overly
/// conservative due to premature rounding. Using the [getDestinationClipBounds]
/// method combined with the external transforms and rounding in the true device
/// coordinate system will produce more accurate results, but this value may
/// provide a more convenient approximation to compare rendering operations to
/// the established clip.
///
/// {@template dart.ui.canvas.conservativeClipBounds}
/// The conservative estimate of the bounds is based on intersecting the bounds
/// of each clip method that was executed with [ClipOp.intersect] and potentially
/// ignoring any clip method that was executed with [ClipOp.difference]. The
/// [ClipOp] argument is only present on the [clipRect] method.
///
/// To understand how the bounds estimate can be conservative, consider the
/// following two clip method calls:
///
/// ```dart
/// void draw(Canvas canvas) {
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(10, 10, 20, 20))
///     ..addRect(const Rect.fromLTRB(80, 80, 100, 100)));
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(80, 10, 100, 20))
///     ..addRect(const Rect.fromLTRB(10, 80, 20, 100)));
///   // ...
/// }
/// ```
///
/// After executing both of those calls there is no area left in which to draw
/// because the two paths have no overlapping regions. But, in this case,
/// [getLocalClipBounds] would return a rectangle from `10, 10` to `100, 100` because it
/// only intersects the bounds of the two path objects to obtain its conservative
/// estimate.
///
/// The clip bounds are not affected by the bounds of any enclosing
/// [saveLayer] call as the engine does not currently guarantee the strict
/// enforcement of those bounds during rendering.
///
/// Methods that can change the current clip include [clipRect], [clipRRect],
/// and [clipPath]. The [restore] method can also modify the current clip by
/// restoring it to the same value it had before its associated [save] or
/// [saveLayer] call.
/// {@endtemplate}   À;áƒŸÀ?eƒb/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the destination coordinate space in which the [Picture] will be rendered.
///
/// Unlike [getLocalClipBounds], the bounds are not rounded out to an integer
/// pixel boundary as the Destination coordinate space may not represent pixels
/// if the [Picture] being constructed will be further transformed when it is
/// rendered or added to a scene. In order to determine the true pixels being
/// affected, those external transforms should be applied first before rounding
/// out the result to integer pixel boundaries. Most typically, [Picture] objects
/// are rendered in a scene with a scale transform representing the Device Pixel
/// Ratio.
///
/// {@macro dart.ui.canvas.conservativeClipBounds}   À?„€İÀ@5€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. À@?À@F  À@LÀ@W   À@eüÀB5¼/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line_dark.png#gh-dark-mode-only) ÀB>	ÀBF  ÀBI	ÀBQ  ÀBTÀB[   ÀBe€±ÀBÿ€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. ÀC	ÀC   ÀC‘ÀDŠ`/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect_dark.png#gh-dark-mode-only) ÀD“	ÀD™  ÀDÀD¥   ÀD¯ÀF)j/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect_dark.png#gh-dark-mode-only) ÀF3ÀF:  ÀF@ÀFG   ÀFQHÀGg/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. ÀGrÀGy  ÀGÀG†  ÀGŒÀG“   ÀGÇÀIC”/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval_dark.png#gh-dark-mode-only) ÀIL	ÀIR  ÀIWÀI^   ÀIh‚)ÀK`ä/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle_dark.png#gh-dark-mode-only) ÀKkÀKs  ÀKuÀK}  ÀK„ÀK‹   ÀK•ƒÛÀOƒc/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc_dark.png#gh-dark-mode-only)
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. ÀO"	ÀO(  ÀO-ÀO5  ÀO@ÀOH  ÀOSÀOY  ÀOcÀOj   ÀOtÀPr€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). ÀP{	ÀP  ÀP†ÀP   ÀP—€İÀQA€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. ÀQKÀQR  ÀQXÀQ`  ÀQgÀQn   ÀQxøÀS4¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. ÀSBÀSI  ÀSOÀSU  ÀSYÀS_  ÀScÀSj   ÀStƒQÀV†‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. ÀV”ÀV›  ÀV¡ÀV§  ÀV®ÀV´  ÀV¸ÀV¿   ÀVÉ€‚ÀW.[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. ÀW:ÀWC   ÀWO„IÀ[fƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [ParagraphBuilder.new] constructor. For more details see
/// [TextAlign] and the discussion at [ParagraphStyle.new].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. À[tÀ[  À[‰À[‘   À[œôÀ]N–/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. À]YÀ]d  À]nÀ]|  À]ƒÀ]Š   À]”‚OÀ_Ÿí/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. À_­À_¸  À_ÂÀ_Ï  À_ÖÀ_İ   À_ç†;Àeà…»/// Draws a set of [Vertices] onto the canvas as one or more triangles.
///
/// The [Paint.color] property specifies the default color to use for the
/// triangles.
///
/// The [Paint.shader] property, if set, overrides the color entirely,
/// replacing it with the colors from the specified [ImageShader], [Gradient],
/// or other shader.
///
/// The `blendMode` parameter is used to control how the colors in the
/// `vertices` are combined with the colors in the `paint`. If there are no
/// colors specified in `vertices` then the `blendMode` has no effect. If
/// there are colors in the `vertices`, then the color taken from the
/// [Paint.shader] or [Paint.color] in the `paint` is blended with the colors
/// specified in the `vertices` using the `blendMode` parameter. For the
/// purposes of this blending, the colors from the `paint` parameter are
/// considered the source, and the colors from the `vertices` are considered
/// the destination. [BlendMode.dst] ignores the `paint` and uses only the
/// colors of the `vertices`; [BlendMode.src] ignores the colors of the
/// `vertices` and uses only the colors in the `paint`.
///
/// All parameters must not be null.
///
/// See also:
///   * [Vertices.new], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. ÀeíÀe÷  Àf Àf  ÀfÀf   Àf&–•À{Æ””/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (final Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. À{ĞÀ{×  À{îÀ|  À|À|)  À|@À|N  À|fÀ|r  À|À|”  À|®À|µ   À|¿›À–Ï˜ä/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.center.dx - 5.0;
///       transformList[i * 4 + 3] = sprite.center.dy - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.center.dx,
///         translateY: sprite.center.dy,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. À–ÜÀ–ã  À–ıÀ—
  À—,À—9  À—SÀ—_  À—zÀ—†  À—¤À—«  À—ÈÀ—Ï   À—Ù8À˜Â€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. À˜Í	À˜Ó  À˜ØÀ˜ß  À˜åÀ˜í  À˜÷À˜ı    À™À KüÀ™   À™e“ À™eÀ™r À™sÀ™„  À™À™–   ÀœÙ!Àœñ   DÀšü€ÜÀ›t  À›À›™  À›¢À›ª  À›¯
À›·  À›»À›Ã  À›ÉÀ›Ñ  ÀšüÀšıÀ›À›HÀ›	À›À›À›GÀ›À›À›!À›&À›"À›)À›1À›9À›AÀ›IÀ›bÀ›PÀ›JÀ›RÀœÿoÀg   ÀœÿÀ ÀÀÀÀ/ÀÀÀ À.À!À(À-À)À0ÀUÀ7À1À9ÀOÀIÀQÀrÀ~  À†	ÀŒ   À’-À£  À­À´  À»ÀÂ  À’À“ÀŸÃ€¹À 3  À KÀ [  À hÀ r  ÀŸÃÀŸÄÀŸÊÀŸ÷ÀŸĞÀŸËÀŸØÀŸöÀŸÙÀŸàÀŸåÀŸáÀŸèÀŸğÀŸøÀ !ÀŸÿÀŸùÀ À €€õÀ¡  À¡À¡  À¡
À¡#  À¡'À¡/  À¡5À¡=  À¡DÀ¡T  À¡aÀ¡k  À €À À ‡À ÔÀ À ˆÀ •À ÓÀ –À À ¢À À ¥À ­À µÀ ½À ÅÀ ÍÀ ÕÀ ñÀ ÜÀ ÖÀ ŞÀ¡yuÀ¡ä   À¡yÀ¡zÀ¡…À¡†À¡ŒÀ¡©À¡’À¡À¡šÀ¡¨À¡›À¡¢À¡§À¡£À¡ªÀ¡ÒÀ¡±À¡«À¡³À¡ÌÀ¡ÆÀ¡ÎÀ¡ò€“À¢k  À¢z	À¢  À¡òÀ¡óÀ¡şÀ¡ÿÀ¢À¢)À¢À¢À¢À¢(À¢À¢À¢ À¢À¢#À¢*À¢YÀ¢1À¢+À¢3À¢SÀ¢MÀ¢UÀ¢‰À¢ù   À¢‰À¢ŠÀ¢•À¢–À¢œÀ¢ºÀ¢£À¢À¢«À¢¹À¢¬À¢³À¢¸À¢´À¢»À¢èÀ¢ÂÀ¢¼À¢ÄÀ¢âÀ¢ÜÀ¢äÀ£€À£‰  À£“	À£›  À£	À£¦  À£À£À£À£À£À£LÀ£%À£ À£-À£KÀ£.À£5À£:À£6À£=À£EÀ£MÀ£wÀ£TÀ£NÀ£VÀ£qÀ£kÀ£sÀ£­HÀ£¾  À£Ä	À£Ì  À£Ğ
À£Ù  À£­À£®À£ù€ŠÀ¤f  À¤m	À¤u  À¤x	À¤€  À£ùÀ£úÀ¤ À¤-À¤À¤À¤À¤,À¤À¤À¤À¤À¤À¤&À¤.À¤TÀ¤5À¤/À¤7À¤NÀ¤HÀ¤PÀ¤‡€‰À¤ù  À¥ À¥  À¤‡À¤ˆÀ¤“À¤”À¤šÀ¤¿À¤ À¤›À¤¨À¤¾À¤©À¤°À¤µÀ¤±À¤¸À¤ÀÀ¤çÀ¤ÇÀ¤ÁÀ¤ÉÀ¤áÀ¤ÛÀ¤ãÀ¥€“À¥Œ  À¥‘	À¥™  À¥œ	À¥¤  À¥À¥À¥ À¥!À¥'À¥TÀ¥-À¥(À¥5À¥SÀ¥6À¥=À¥BÀ¥>À¥EÀ¥MÀ¥UÀ¥zÀ¥\À¥VÀ¥^À¥tÀ¥nÀ¥vÀ¥«€²À¥¼  À¥ÆÀ¥Ó  À¥«À¥¬À¦a{À¦¼  À¦ÇÀ¦Ô  À¦aÀ¦bÀ¦hÀ¦À¦nÀ¦iÀ¦vÀ¦ŒÀ¦wÀ¦~À¦ƒÀ¦À¦†À¦À¦ªÀ¦•À¦À¦—À¦à€À¦ø   À¦àÀ¦áÀ§q€À§Ï  À§İÀ§ê  À§qÀ§rÀ§xÀ§À§~À§yÀ§†À§œÀ§‡À§À§“À§À§–À§À§½À§¥À§ŸÀ§§À§öØÀ¨  À¨	À¨  À¨ À¨%  À¨?À¨E  À§öÀ§÷À¨-À¨3À¨4À¨RÀ©Ò€ëÀª_  ÀªiÀªq  Àªv
Àª~  Àª‚ÀªŠ  ÀªÀª˜  ÀªŸ
Àª¤  Àª«Àª±  À©ÒÀ©ÓÀ©ÙÀª#À©ßÀ©ÚÀ©çÀª"À©èÀ©ïÀ©ôÀ©ğÀ©÷À©ÿÀªÀªÀªÀªÀª$ÀªMÀª+Àª%Àª-ÀªGÀªAÀªIÀªÁ€œÀªÒ  ÀªÜÀªã  ÀªêÀªğ  ÀªÁÀªÂÀªıÀ«a€‘À«Â  À«ÍÀ«Ú  À«àÀ«æ  À«aÀ«bÀ«hÀ«“À«nÀ«iÀ«vÀ«’À«wÀ«~À«ƒÀ«À«†À«À«”À«°À«›À«•À«À«övÀ¬  À¬	À¬  À¬À¬"  À«öÀ«÷À¬/À¬p€•À¬×  À¬áÀ¬î  À¬óÀ¬ù  À¬pÀ¬qÀ¬wÀ¬©À¬}À¬xÀ¬…À¬¨À¬†À¬À¬’À¬À¬•À¬œÀ¬¡À¬À¬¤À¬ªÀ¬ÅÀ¬±À¬«À¬³À­	€ÁÀ­   À­	À­
À­Î€ŒÀ®2  À®FÀ®S  À­ÎÀ­ÏÀ­ÕÀ­úÀ­ÛÀ­ÖÀ­ãÀ­ùÀ­äÀ­ëÀ­ğÀ­ìÀ­óÀ­ûÀ® À®À­üÀ®À®^€ÍÀ®o   À®^À®_À¯/€˜À¯™  À¯³À¯À  À¯/À¯0À¯6À¯[À¯<À¯7À¯DÀ¯ZÀ¯EÀ¯LÀ¯QÀ¯MÀ¯TÀ¯\À¯‡À¯cÀ¯]À¯eÀ¯ËpÀ¯Ü  À¯æÀ¯í  À¯óÀ¯ş  À¯ËÀ¯ÌÀ°?€•À°¯  À°º	À°¿  À°ÅÀ°Ê  À°?À°@À°FÀ°rÀ°LÀ°GÀ°TÀ°qÀ°UÀ°\À°aÀ°]À°dÀ°lÀ°sÀ°À°zÀ°tÀ°|À°—À°‘À°™À°Ø€ÊÀ°é  À°ò	À°ú  À°ı	À±  À±À±  À°ØÀ°ÙÀ±¦€éÀ²(  À²2	À²:  À²=	À²E  À²H	À²P  À²S	À²[  À²^À²n  À²{À²…  À±¦À±§À±­À±úÀ±³À±®À±»À±ùÀ±¼À±ÃÀ±ÈÀ±ÄÀ±ËÀ±ÓÀ±ÛÀ±ãÀ±ëÀ±óÀ±ûÀ²À²À±üÀ²À²“ZÀ²¤  À²®À²µ  À²“À²”À²ñ€ŸÀ³T  À³_À³o  À³|À³†  À²ñÀ²òÀ²øÀ³%À²şÀ²ùÀ³À³$À³À³À³À³À³À³À³&À³BÀ³-À³'À³/À³”À³¥  À³®	À³´  À³¹À³À  À³”À³•À´©€óÀµ+  Àµ5Àµ=  ÀµB
ÀµJ  ÀµNÀµV  Àµ\Àµd  ÀµkÀµ{  ÀµˆÀµ’  À´©À´ªÀ´°À´ıÀ´¶À´±À´¾À´üÀ´¿À´ÆÀ´ËÀ´ÇÀ´ÎÀ´ÖÀ´ŞÀ´æÀ´îÀ´öÀ´şÀµÀµÀ´ÿÀµÀµ €Àµ±  Àµ»ÀµÂ  ÀµÈÀµÏ  Àµ Àµ¡À¶B€ºÀ¶­  À¶¸À¶Å  À¶ËÀ¶Û  À¶èÀ¶ò  À¶BÀ¶CÀ¶IÀ¶~À¶OÀ¶JÀ¶WÀ¶}À¶XÀ¶_À¶dÀ¶`À¶gÀ¶oÀ¶wÀ¶À¶›À¶†À¶€À¶ˆÀ· €äÀ·  À·À·#  À·)À·0  À·6À·=  À· À·À·è€×À¸\  À¸hÀ¸u  À¸{À¸ˆ  À¸À¸  À¸«À¸µ  À·èÀ·éÀ·ïÀ¸,À·õÀ·ğÀ·ıÀ¸+À·şÀ¸À¸
À¸À¸À¸À¸À¸%À¸-À¸JÀ¸4À¸.À¸6À¸ÃÀ¸Ô  À¸İ	À¸ã  À¸èÀ¸ï  À¸ÃÀ¸ÄÀ¹Ø€óÀºZ  ÀºdÀºl  Àºq
Àºy  Àº}Àº…  Àº‹Àº“  ÀºšÀºª  Àº·ÀºÁ  À¹ØÀ¹ÙÀ¹ßÀº,À¹åÀ¹àÀ¹íÀº+À¹îÀ¹õÀ¹úÀ¹öÀ¹ıÀºÀºÀºÀºÀº%Àº-ÀºHÀº4Àº.Àº6ÀºÏ€¨Àºà  ÀºëÀºó  ÀºõÀºı  À»À»  ÀºÏÀºĞÀ»{€ÜÀ»÷  À¼À¼  À¼À¼  À¼À¼  À¼&À¼6  À¼CÀ¼M  À»{À»|À»‚À»ÇÀ»ˆÀ»ƒÀ»À»ÆÀ»‘À»˜À»À»™À» À»¨À»°À»¸À»ÀÀ»ÈÀ»åÀ»ÏÀ»ÉÀ»ÑÀ¼[À¼l  À¼t	À¼z  À¼À¼‡  À¼’À¼š  À¼¥À¼«  À¼µÀ¼¼  À¼[À¼\À½gtÀ½ş  	À¾À¾  À¾!
À¾)  À¾3À¾;  À¾GÀ¾O  À¾\À¾d  À¾uÀ¾}  À¾À¾”  À¾¤À¾´  À¾ÇÀ¾Ñ  À½gÀ½hÀ½nÀ½ÑÀ½tÀ½oÀ½|À½ĞÀ½}À½„À½‰À½…À½ŒÀ½”À½œÀ½¤À½¬À½´À½¼À½ÂÀ½ÊÀ½ÒÀ½ìÀ½ÙÀ½ÓÀ½ÛÀ¾ßxÀ¾ğ  À¾ù	À¾ÿ  À¿À¿  À¾ßÀ¾àÀ¿[€¾À¿Ì  À¿ÖÀ¿ã  À¿èÀ¿ø  ÀÀÀÀ  À¿[À¿\À¿bÀ¿À¿hÀ¿cÀ¿pÀ¿À¿qÀ¿xÀ¿}À¿yÀ¿€À¿‡À¿ŒÀ¿ˆÀ¿À¿—À¿ŸÀ¿ºÀ¿¦À¿ À¿¨ÀÀ~ÀÀ.  ÀÀ8ÀÀ?  ÀÀEÀÀM  ÀÀTÀÀ[  ÀÀÀÀÀÁŸÀÂ-  ÀÂ8ÀÂ@  ÀÂFÀÂN  ÀÂPÀÂX  ÀÂZÀÂj  ÀÂwÀÂ  ÀÂ‹ÀÂ  ÀÁŸÀÁ ÀÁ¦ÀÁûÀÁ®ÀÁ§ÀÁ¶ÀÁúÀÁ·ÀÁ¾ÀÁÃÀÁ¿ÀÁÆÀÁÍÀÁÒÀÁÎÀÁÕÀÁİÀÁåÀÁíÀÁõÀÁüÀÂÀÂÀÁıÀÂÀÂ§ƒ¦ÀÂ¸  ÀÂÆÀÂÍ  ÀÂÓÀÂÙ  ÀÂİÀÂã  ÀÂçÀÂî  ÀÂ§ÀÂ¨ÀÆQõÀÇ  ÀÇ)ÀÇ1  ÀÇ=ÀÇE  ÀÇSÀÇ[  ÀÇhÀÇp  ÀÇÀÇ‡  ÀÇ—ÀÇŸ  ÀÇ­ÀÇµ  ÀÇÂÀÇÊ  ÀÇÙÀÇá  ÀÇñÀÈ  ÀÈÀÈ  ÀÈ.ÀÈ3   ÀÆQÀÆRÀÆXÀÆİÀÆ`ÀÆYÀÆhÀÆÜÀÆiÀÆpÀÆuÀÆqÀÆxÀÆÀÆ„ÀÆ€ÀÆ‡ÀÆÀÆ—ÀÆŸÀÆ§ÀÆ¯ÀÆ·ÀÆ¿ÀÆÇÀÆÏÀÆ×ÀÆŞÀÆşÀÆåÀÆßÀÆçÀÈJƒ¸ÀÈ[  ÀÈiÀÈp  ÀÈvÀÈ|  ÀÈƒÀÈ‰  ÀÈÀÈ”  ÀÈJÀÈKÀÌ‚ÀÌÈ  ÀÌŞÀÌæ  ÀÌòÀÌú  ÀÍÀÍ  ÀÍ#ÀÍ+  ÀÍ=ÀÍE  ÀÍXÀÍ`  ÀÍnÀÍv  ÀÍƒÀÍ‹  ÀÍšÀÍ¢  ÀÍ²ÀÍÂ  ÀÍÕÀÍß  ÀÍïÀÍô   ÀÌÀÌÀÌÀÌ’ÀÌÀÌÀÌÀÌ‘ÀÌÀÌ%ÀÌ*ÀÌ&ÀÌ-ÀÌ4ÀÌ9ÀÌ5ÀÌ<ÀÌDÀÌLÀÌTÀÌ\ÀÌdÀÌlÀÌtÀÌ|ÀÌ„ÀÌŒÀÌ“ÀÌ³ÀÌšÀÌ”ÀÌœÀÎ€„ÀÎ  ÀÎ(ÀÎ1  ÀÎÀÎÀÎ“€‰ÀÎ÷  ÀÏÀÏ  ÀÎ“ÀÎ”ÀÎšÀÎÆÀÎ ÀÎ›ÀÎ¨ÀÎÅÀÎ©ÀÎ°ÀÎµÀÎ±ÀÎ¸ÀÎ¿ÀÎÄÀÎÀÀÎÇÀÎåÀÎÎÀÎÈÀÎĞÀÏ GÀÏ1  ÀÏ?ÀÏJ  ÀÏTÀÏ\  ÀÏ ÀÏ!ÀĞk€±ÀĞ|  ÀĞ‡ÀĞ’  ÀĞœÀĞª  ÀĞ±ÀĞ¸  ÀĞkÀĞlÀÑ ÀÑ1  ÀÑ?ÀÑJ  ÀÑTÀÑa  ÀÑhÀÑo  ÀÑ ÀÑ!ÀÒ8€ÓÀÒ«  ÀÒ·ÀÒÇ  ÀÒÔÀÒŞ  ÀÒèÀÒí  ÀÒ÷ÀÓ  ÀÒ8ÀÒ9ÀÒ?ÀÒ{ÀÒEÀÒ@ÀÒMÀÒzÀÒNÀÒUÀÒZÀÒVÀÒ]ÀÒeÀÒmÀÒtÀÒ|ÀÒ™ÀÒƒÀÒ}ÀÒ…ÀÓ€ÈÀÓ   ÀÓ-ÀÓ7  ÀÓ@ÀÓK  ÀÓUÀÓ\  ÀÓÀÓÀÓÛ€İÀÔW  ÀÔeÀÔo  ÀÔxÀÔ}  ÀÔ‡ÀÔ—  ÀÔ¤ÀÔ®  ÀÓÛÀÓÜÀÓâÀÔ%ÀÓèÀÓãÀÓğÀÔ$ÀÓñÀÓøÀÓıÀÓùÀÔ ÀÔÀÔÀÔÀÔÀÔÀÔÀÔ&ÀÔEÀÔ-ÀÔ'ÀÔ/ÀÔ¼ˆ"ÀÔÍ  ÀÔ×ÀÔŞ  ÀÔõÀÕ  ÀÕ$ÀÕ0  ÀÕGÀÕU  ÀÕmÀÕy  ÀÕ”ÀÕ›  ÀÕµÀÕ¼  ÀÔ¼ÀÔ½ÀÜâ„§ÀÜó  Àİ Àİ  Àİ!Àİ.  ÀİPÀİ]  ÀİwÀİƒ  ÀİÀİª  ÀİÈÀİÏ  ÀİìÀİó  ÀÜâÀÜãÀá¥Àâ2  	ÀâDÀâT  ÀâgÀâq  ÀâÀâ†  ÀâŸÀâ§  Àâ³ÀâÀ  ÀâÔÀâá  ÀâíÀâù  ÀãÀã  ÀãÀã)  ÀáÀáÀá”Àâ ÀáœÀá•Àá¤ÀáÿÀá¥Àá¬Àá±Àá­Àá´Àá¼ÀáÄÀáËÀáÒÀá×ÀáÓÀáÚÀáâÀáêÀáòÀáùÀâÀâÀâÀâÀâ
Àã6€¸ÀãG  ÀãR	ÀãX  Àã]Àãd  ÀãjÀãr  Àã|Àã‚  Àã6Àã7Àãò€ÎÀäk  ÀäwÀä„  Àä‰	Àä  Àä”Àäœ  Àä¦Àä¬  ÀãòÀãóÀãùÀä;ÀãÿÀãúÀäÀä:ÀäÀäÀäÀäÀäÀäÀä#ÀäÀä&Àä.Àä6Àä<ÀäYÀäCÀä=ÀäEÀäÄKÀä×   ÀäÄÀäÅ ÀåŠ¸ÀæßN/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method.  ÀæëÀçû€è/// A callback that is invoked to report a picture creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀèÀé€ë/// A callback that is invoked to report the picture disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. Àî}€ÇÀï6€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀïH€ïÀğ"€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   Àé)DÀêN/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped. ÀêV	Àê[  Àêa
Àêf   Àêqƒ‚ÀíĞƒ6/// Synchronously creates a handle to an image of this picture.
///
/// {@template dart.ui.painting.Picture.toImageSync}
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped.
///
/// The image object is created and returned synchronously, but is rasterized
/// asynchronously. If the rasterization fails, an exception will be thrown
/// when the image is drawn to a [Canvas].
///
/// If a GPU context is available, this image will be created as GPU resident
/// and not copied back to the host. This means the image will be more
/// efficient to draw.
///
/// If no GPU context is available, the image will be rasterized on the CPU.
/// {@endtemplate} ÀíÜ	Àíá  Àíç
Àíì   Àí÷€‚Àîon/// Release the resources used by this object. The object is no longer usable
/// after this method is called.    Àğ;ˆºÀğF  Àğ€µÀñ=Àñ>Àñ?€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder].  À÷ À÷% À÷1À÷;€õÀ÷P   À÷;À÷<Àø4€Àø¯   Àø4Àø5Àø@ÀøAÀøGÀøfÀøOÀøHÀøWÀøeÀøXÀø_ÀødÀø`ÀøgÀøšÀønÀøhÀøpÀø”ÀøÀø–ÀñF½Àñ`  Àñh	Àñm  Àñs
Àñx  ÀñFÀñGÀó€°Àóv  Àó	Àó„  ÀóŠ
Àó  Àó–Àó®  ÀóÀóÀóÀóEÀóÀóÀóÀóDÀóÀó&Àó+Àó'Àó.Àó6Àó>ÀóFÀóaÀóMÀóGÀóOÀó»5ÀóÍ  ÀóÙ	ÀóŞ  Àóä
Àóé  Àó»Àó¼Àôô€£Àõb  Àõo	Àõt  Àõz
Àõ  Àõ†Àõ  ÀôôÀôõÀôûÀõ0ÀõÀôüÀõ	Àõ/Àõ
ÀõÀõÀõÀõÀõ!Àõ)Àõ1ÀõPÀõ8Àõ2Àõ:Àõ›€°Àõ¬   Àõ›ÀõœÀöO€ÍÀ÷k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  Àö¿ÀöÀÀöÆÀöãÀöÌÀöÇÀöÔÀöâÀöÕÀöÜÀöáÀöİÀöäÀöÿÀöëÀöåÀöíÀøÈ+ÀøÛ   ÀøÈÀøÉ Àø÷„ÀùÛ€Ô/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method. Àùï€× Àú›Àúª€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor.   ÀúÊ™ÀüWu/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   Àüg,Àı„
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.    Àı—„Àı¢  Àıù, ÀıùÀş   ÀDÀS  Àş4Àş£   ÀşÀşÀş)aÀş{   Àş)Àş*Àş0ÀşFÀş6Àş1Àş>ÀşEÀş?ÀşGÀşiÀşNÀşHÀşPÀşÆæÀşÚ   ÀşÆÀşÇÀ °€À  À%À5  À °À ±À ·À ÜÀ ½À ¸À ÅÀ ÛÀ ÆÀ ÍÀ ÒÀ ÎÀ ÕÀ İÀÀ äÀ ŞÀ æÀ_LÀr   À_À` À¯›À
T/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. À‚P À À¦p/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.À­(À³  ÀÛÀá  ÀúÀ   ÀºÀÀÀÅÀÔÀÆÀéÀïÀğÀÀÀÀ0ÀcÀ*ÀÀ-À2	Ài,Àz À‹À½&ÀÎ ÀáÀç'Àø À
ÀÀÀ#À# À1À/À4À9#ÀJ ÀXÀVÀ[À`&Àq À‚À€À…À‹€¼ÀB€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. ÀL4Àz/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. À…iÀäO/// The standard deviation of the Gaussian to convolve with the shadow's shape. À	s€®À	ón/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   ÀŠGÀ   ÀŠÀ‹Àó|À	h/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// À	'À	/   À
%‚‹À5õ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   À´€õÀ[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. À!À)   À­…×À·ƒÔ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} À¼	ÀÅ  ÀÇ	ÀĞ  ÀÒÀÚ   ÀˆƒÀM€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} ÀVÀe  ÀgÀv  ÀxÀ€   À“€óÀ­  À°À¸  À“À”ÀƒÓÀŸ  À®À½   ÀfLÀy   ÀfÀg À¶ÌÀq€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. À¦ ÀµÀ¶À· À¸À¾   À&¹À&½  À&ÉÀ&Î À&ßÀ&hNÀ&¤1/// The length, in bytes, of the underlying data.   À&éÀ'ry/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀÊgÀL^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. ÀZÀe   À5ƒGÀÍr/// Create a buffer from the asset with key [assetKey].
///
/// Throws an [Exception] if the asset does not exist. À×Àß   À"€÷À#i/// Create a buffer from the file with [path].
///
/// Throws an [Exception] if the asset does not exist. À#À#$   À${€•À$à  À$æÀ$ñ  À$öÀ%  À${À$|À$‚À$ªÀ$ŠÀ$ƒÀ$’À$©À$“À$›À$£À$«À$ËÀ$²À$¬À$´À%€§À%‚  À%‘À%™  À%¢À%²  À%À%À%À%CÀ%#À%À%+À%BÀ%,À%4À%<À%DÀ%mÀ%KÀ%EÀ%MÀ%¿€¥À&,  À&:À&B  À&KÀ&[  À%¿À%ÀÀ%ÆÀ%îÀ%ÎÀ%ÇÀ%ÖÀ%íÀ%×À%ßÀ%çÀ%ïÀ&À%öÀ%ğÀ%øÀ(‚£À*‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   À*«€ÕÀ+uk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À+À+À+"À+?À+(À+#À+0À+>À+1À+8À+=À+9À+@À+cÀ+GÀ+AÀ+I À+„‰‰À,I€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. À,]‚çÀ.”À.•À.˜Ğ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À.À.¯  À.¼À.Ê  À.ÔÀ.â  À.íÀ.ó  À/  À/    À0¯yÀ1"d/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À1,{À1 e/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À1«€…À2"h/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   À/HcÀ/²H/// Creates an image descriptor from encoded data in a supported format. À/ºÀ/Ë   À24€øÀ3"€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).   À30ÛÀ4Ó‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. À4åÀ4ë  À4÷À4ı    À5<À5  À5qÀ5‡À5ˆÀ5‰   À5ƒ£À7ÆÀ7ÇÀ7ÊĞ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À7ĞÀ7á  À7îÀ7ü  À8À8  À8À8%  À82 À8H   À:åÀ:ê  À;£À;¨  À<gÀ<l  À;k4À;   À;kÀ;lÀ<,7À<@   À<,À<-À=LÀ=   À=À=	À97€²À9ª  À9·À9È  À9ÏÀ9à  À97À98À9>À9mÀ9FÀ9?À9NÀ9lÀ9OÀ9WÀ9^À9cÀ9_À9fÀ9nÀ9•À9uÀ9oÀ9wÀ9í€ôÀ:k  À:tÀ:…  À:“À:¤  À:«	À:°  À:¶
À:»  À:ÂÀ:Ç  À:ĞÀ:Õ  À9íÀ9îÀ9ôÀ:.À9úÀ9õÀ:À:-À:À:À:À:À:!À:(À:/À:RÀ:6À:0À:8À:õrÀ;[   À:õÀ:öÀ:üÀ;À;À:ıÀ;À;À;À;À;À;À;À;JÀ;"À;À;$À;DÀ;>À;FÀ;´tÀ<   À;´À;µÀ;»À;ÙÀ;ÂÀ;¼À;ÊÀ;ØÀ;ËÀ;ÒÀ;×À;ÓÀ;ÚÀ<
À;áÀ;ÛÀ;ãÀ<À;şÀ<À<€‚À<í   À<À<€À<†À<¤À<À<‡À<•À<£À<–À<À<¢À<À<¥À<ÜÀ<¬À<¦À<®À<ÖÀ<ĞÀ<ØÀ=UpÀ=»   À=UÀ=VÀ=aÀ=bÀ=hÀ=…À=nÀ=iÀ=vÀ=„À=wÀ=~À=ƒÀ=À=†À=©À=À=‡À=À=Éƒ(À=ã  À=õÀ=û  À>À>  À=ÉÀ=ÊÀ@õ€¾ÀAn  ÀA€ÀA‡  ÀAÀA•  ÀA¡ÀA¦  À@õÀ@öÀ@üÀA/ÀAÀ@ıÀA
ÀA.ÀAÀAÀAÀAÀAÀA"ÀA)ÀA0ÀA\ÀA7ÀA1ÀA9ÀA·€’ÀAÊ   ÀA·ÀA¸ ÀN>ƒùÀOºu/// An exception thrown by [Canvas.drawImage] and related methods when drawing
/// an [Image] created via [Picture.toImageSync] that is in an invalid state.
///
/// This exception may be thrown if the requested image dimensions exceeded the
/// maximum 2D texture size allowed by the GPU, or if no GPU surface or context
/// was available for rasterization at request time. ÀOñBÀPÀPÀP ÀPÀP  ÀP&
ÀP,   ÀP7IÀPy2/// A string containing details about the failure. ÀP…iÀPéO/// If available, the stack trace at the time [Picture.toImageSync] was called.  ÀPóBÀQ   ÀPóÀPô  ±çÀ Oò½‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  ½¹€î¾¢€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) ¾¬H¿ñ4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) ¿ùMÀ AC9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À AKìÀ C0Ğ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À C<­À Dâ‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À Dî‚šÀ Gƒ‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À G‚„À J‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À J‚˜À L¨‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À L³‚À O;‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À OF‚gÀ Q¦‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À Q²‚]À T‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À T;À UL+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À UTƒOÀ XŸƒ,/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// This is the right blend mode for cross-fading between two images. Consider
/// two images A and B, and an interpolation time variable _t_ (from 0.0 to
/// 1.0). To cross fade between them, A should be drawn with opacity 1.0 - _t_
/// into a new layer using [BlendMode.srcOver], and B should be drawn on top
/// of it, at opacity _t_, into the same layer, using [BlendMode.plus].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À X¨ƒVÀ [öƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À \L…!À ag„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À a‹ƒŞÀ ebƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À en7À fŸ"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À fª:À gİ$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À gé{À iZb/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À ii‘À jñy/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À jÿƒâÀ nØƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À næsÀ pPU/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À p^ÅÀ r¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À r(ÔÀ só²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À t‚ÙÀ vÒ‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À vü‚÷À yğ‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À yø‚dÀ |R‚=/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À |a‚ãÀ ?‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À I‚À Ì‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À ÛŒ{À ‡U…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À ‡æ€ÙÀ ˆ»€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À ˆÄ€²À ‰s€¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À ‰{‚À Œ‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À Œ‚EÀ O‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À X†ÆÀ K€±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À Y…À Úr/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À ãËÀ ’©µ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À ’³‚hÀ •‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À • ˆÀ –Êg/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À –Ù‚YÀ ™-‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À ™7ÌÀ šş®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ›‚À ÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À $‚ÖÀ ºT/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À &€·À Ù€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À âÀ Ÿñ/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À ŸüŒ‡À  0./// Different ways to clip a widget's content.  À  9‚8À ¢m‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À ¢v‚_À ¤Í‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À ¤Úƒ.À §ÿƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À ¨„sÀ ¬j„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À ïnƒ×À ñ?Ë/// The color space describes the colors that are available to an [Image].
///
/// This value can help decide which [ImageByteFormat] to use with
/// [Image.toByteData]. Images that are in the [extendedSRGB] color space
/// should use something like [ImageByteFormat.rawExtendedRgba128] so that
/// colors outside of the sRGB gamut aren't lost.
///
/// This is also the result of [Image.colorSpace].
///
/// See also: https://en.wikipedia.org/wiki/Color_space  À ñN€ØÀ ò"€Ç/// The sRGB color space.
///
/// You may know this as the standard color space for the web or the color
/// space of non-wide-gamut Flutter apps.
///
/// See also: https://en.wikipedia.org/wiki/SRGB À ò*À ó6/// A color space that is backwards compatible with sRGB but can represent
/// colors outside of that gamut with values outside of [0..1]. In order to
/// see the extended values an [ImageByteFormat] like
/// [ImageByteFormat.rawExtendedRgba128] must be used.    À óG‰À ôÓY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À ôç€‚À õbt/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À õn€À õíx/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. À ö€»À ö¯€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À öÁ‚ÎÀ ù}‚/// Raw extended range RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 32 bit
/// float (IEEE 754 binary32) per channel.
///
/// Example usage:
///
/// ```dart
/// import 'dart:ui' as ui;
/// import 'dart:typed_data';
///
/// Future<Map<String, double>> getFirstPixel(ui.Image image) async {
///   final ByteData data =
///       (await image.toByteData(format: ui.ImageByteFormat.rawExtendedRgba128))!;
///   final Float32List floats = Float32List.view(data.buffer);
///   return <String, double>{
///     'r': floats[0],
///     'g': floats[1],
///     'b': floats[2],
///     'a': floats[3],
///   };
/// }
/// ``` À ù”‚¾À üO‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    À üWƒ?À ü›>/// The format of pixel data given to [decodeImageFromPixels].  À ü«€ÙÀ ı|€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. À ı‰€ÙÀ şZ€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. À şg,À ÿˆ/// Each pixel is 128 bits, where each color component is a 32 bit float that
/// is normalized across the sRGB gamut.  The first float is the red
/// component, followed by: green, blue and alpha. Premultiplied alpha isn't
/// used, matching [ImageByteFormat.rawExtendedRgba128].    ÀwÖƒ•Àxs€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  Àx„¯Àz,—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> Àz80À{a/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    À{mˆLÀ|!€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  À|3£À}Ì„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. À}Ú‡ÀXk/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation Àe$À€„/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. À€‚À‚n/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation À‚£Àƒ¥}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    À"ƒ{À˜4/// Styles to use for blurs in [MaskFilter] objects.  Àß€–Ào€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. Àz€ÍÀB€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. ÀL€æÀ-€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. À7cÀ•Y/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    Àh;“Ào†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  Ào‚£Àq¹‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) ÀqÃƒ5Àtğƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) Àtıƒ|ÀxsƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) Àx~‚½À{6‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    ÀÎÎ‚ÃÀÏˆw/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀÏ—QÀÏßE/// Draw each sequence of three points as the vertices of a triangle. ÀÏí[ÀĞ;K/// Draw each sliding window of three points as the vertices of a triangle. ÀĞMAÀÑƒ)/// Draw the first point and each sliding window of two points as the vertices
/// of a triangle.
///
/// This mode is not natively supported by most backends, and is instead
/// implemented by unrolling the points into the equivalent
/// [VertexMode.triangles], which is generally more efficient.    Àı›„-Àşr€/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints] and [Canvas.drawRawPoints].  Àş€·À 1/// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). À <€éÀ €×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). À*€›À¾€‹/// Draw the entire sequence of points as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    ÀÊÀHx/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  ÀSBÀ‹5/// Subtract the new region from the existing region. ÀšBÀÓ6/// Intersect the new region from the existing region.       „‹o„  „	„£   „üt…  ……   …r€…w  …†…   †€Û†  ††%   †à€†å  †ô†ü   ‡om‡u  ‡‡ˆ  ‡Š‡’   À.BpÀ.b  À.mÀ.u  À.BÀ.CÀ.IÀ.ZÀ.JÀDi‰?ÀLA‡‰/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported:
/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. ÀLZÀLe  ÀLnÀLt  ÀL‚ÀLˆ  ÀL—ÀL  ÀL­ÀMªŠ¡ÀUäˆ+/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been created,
/// so the caller must relinquish ownership of the [buffer] when they call this
/// method.
///
/// The [targetWidth] and [targetHeight] arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. ÀVÀV  ÀV#ÀV)  ÀV7ÀV=  ÀVLÀVR  ÀVbÀXM‰„À_d‡/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary
/// data). The data can be for either static or animated images. The following
/// image formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been
/// created, so the caller must relinquish ownership of the [buffer] when they
/// call this method.
///
/// The [getTargetSize] parameter, when specified, will be invoked and passed
/// the image's intrinsic size to determine the size to decode the image to.
/// The width and the height of the size it returns must be positive values
/// greater than or equal to 1, or null. It is valid to return a
/// [TargetImageSize] that specifies only one of `width` and `height` with the
/// other remaining null, in which case the omitted dimension will be scaled to
/// maintain the aspect ratio of the original dimensions. When both are null or
/// omitted, the image will be decoded at its native resolution (as will be the
/// case if the [getTargetSize] parameter is omitted).
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. À_…À_–  À_¡&À_»   ÀaÓsÀaã  ÀaøÀaı  ÀbÀb   Àj©ÀkP0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. ÀkdÀko  ÀktÀkŠ   ÀkÅ€ïÀkÒ  ÀkìÀk÷  ÀküÀl   Àl¶‹ÀrY…/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `format`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	ÀrrÀr}  Àr†	Àr‹  Àr“
Àr˜  Àr¡Àr®  Àr·ÀrÍ  ÀrÚÀrà  ÀrëÀrñ  ÀrÿÀs  ÀsÀs  Às*À{@€ëÀ{J  À{[À{h   À|-›À|9  À|JÀ|X   À}Ê$À}Ö  À}çÀ}ï  À}öÀ}ş   ÀHL‚¼ÀHV ÀH`ÀH`ÀHcÀHs   ÀK
ƒ2ÀKWB/// A variant of `_futurize` that can communicate specific errors.ÀKjÀKjÀKm"ÀK†    À ÿ˜dÀ ÿÌ+/// Signature for [Image] lifecycle events.  À ÿïÀ ÿö   À.´mÀ.î1/// Callback signature for [decodeImageFromList].  À/À/   ÀbHdÀcI€ø/// Signature for a callback that determines the size to which an image should
/// be decoded given its intrinsic size.
///
/// See also:
///
///  * [instantiateImageCodecWithSize], which used this signature for its
///    `getTargetSize` argument.  ÀcÀc„  Àc•Àcš   ÀålÀåI-/// Signature for [Picture] lifecycle events.  ÀånÀåw   ÀBMdÀBŠ4/// Generic callback signature, used by [_futurize].ÀB”ÀB” ÀB§ÀBª   ÀB³€…ÀBù=/// Generic callback signature, used by [_futurizeWithError].ÀCÀC ÀCÀC"  ÀC)ÀC2   ÀC:€ÕÀCÕ€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.ÀCáÀCá ÀC÷ÀD   ÀD€±ÀDv\/// Signature for a method that receives a [_CallbackWithError].
/// See also: [_Callbacker]ÀD‹ÀD‹ ÀD¡ÀD¹       ›| <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu¬­íó@PuœÂÈ‘‘‘\‘i‘‘À‘â’’2’3’ˆ’’³’Ú“ “M“}“ƒ“Æ“Ì””R”ˆ”¾”ô•6•7•e•k•“•™•Á•ç––3–F–G–€–†–Õ–÷—&—'—Z—`—±—Ó—ù—ú˜1˜^˜_˜˜˜Æ˜Ç˜ÿ™,™-™v™¬™²™êšš5š9š:šƒšËšÑ›	›/›]››’›“›ãœœœNœgœ™œœœç#[v¦ª«ü)/g²¶·õŸ2ŸRŸrŸxŸ¹Ÿ½Ÿ¾ 	  c  ‡ Å ã¡#¡^¡›¡×¢¢¢¢<¢B¢Š¢Í¢Ó££j£©£ï£õ¤B¤Œ¤×¥#¥q¥Á¦¦_¦Œ¦’¦á§§6§K§b§w§†§®§¶§Ã§Ú§ü¨¨*¨n¨®¨ò©4©?©G©M©Q©R©•©Û©áª-ªtª¿««Y«™«Á¬ ¬¬¬F¬l¬£¬À¬Î­­^­¦­¯­Ì­ş®,®L®i®{®Æ¯¯b¯k¯q¯u¯v¯Ã¯É¯ô°'°b°f°g°s°–°¸°Ë°Ñ°ı±±±1±R±V±W±c±‰±Š±–±ä±æ±ç²²²k²µ²Ô²Ø³)³v³Å´´c´®´ò´öµFµ‘µâ¶.¶|¶É··[·ª·ğ¸¸¸]¸ª¸ô¹F¹“¹äº%º)ºPºTº¢ºã»4»»Ò¼!¼p¼‹¼¼¼¡¼ì¼ı½½]½p½¶½·½û¾¾=¾C¾ ¾©¾ª¾é¾ï¿>¿M¿S¿¿”¿ï¿ö¿÷À @6À @<À @‡À @˜À @À @àÀ @æÀ AAÀ AHÀ AIÀ A†À AŒÀ AÚÀ B+À BHÀ BNÀ BœÀ BÉÀ BÏÀ C.À C9À C:À CxÀ C~À C§À C­À CûÀ DÀ D`À DfÀ DµÀ DàÀ DëÀ DìÀ E4À EÀ EÎÀ EÜÀ EâÀ F!À F'À FtÀ F¼À FÌÀ FÒÀ GÀ G$À GÀ GŠÀ G‹À GØÀ H&À HpÀ HvÀ H°À H¶À IÀ IUÀ I[À I§À I­À J
À JÀ JÀ JcÀ J¶À KÀ KÀ KKÀ KQÀ KÀ KïÀ KõÀ LBÀ LHÀ L¦À L°À L±À MÀ MSÀ MÀ M£À MŞÀ MäÀ N6À N‚À NˆÀ NÕÀ NÛÀ O9À OCÀ ODÀ O“À O³À O¹À PÀ PÀ P]À P©À PİÀ PãÀ Q.À Q?À QEÀ Q¤À Q¯À Q°À QÿÀ RÀ R À RnÀ RtÀ RÄÀ SÀ S?À SEÀ SÀ S¡À S§À TÀ TÀ TÀ TbÀ T–À TœÀ TéÀ TïÀ UJÀ UQÀ URÀ U‘À U—À UæÀ V2À VXÀ V^À V¬À V²À WÀ WQÀ W¢À WñÀ X;À XAÀ XÀ X¥À X¦À XğÀ XöÀ YEÀ Y”À YšÀ YëÀ ZÀ ZÀ ZkÀ ZqÀ ZÑÀ Z×À ZçÀ ZíÀ [/À [wÀ [“À [İÀ [ôÀ \ À \À \IÀ \JÀ \•À \»À \ÁÀ ]À ]ZÀ ]‰À ]À ]àÀ ^,À ^RÀ ^XÀ ^¨À ^÷À _HÀ _NÀ _À _¿À _ÅÀ `#À `)À `9À `?À `À ` À `èÀ aÀ aNÀ aeÀ aˆÀ a‰À aÒÀ bÀ bÀ bXÀ b¦À b÷À cÀ cÀ chÀ cµÀ cäÀ cêÀ dIÀ dOÀ d_À deÀ dÀ dåÀ e5À e`À ekÀ elÀ eºÀ eÙÀ eßÀ f(À f9À f?À fÀ f§À f¨À f÷À gÀ gÀ geÀ gvÀ g|À gÛÀ gæÀ gçÀ h"À h(À htÀ hÁÀ hğÀ höÀ iXÀ ifÀ igÀ iºÀ iÀÀ jÀ jYÀ jˆÀ jÀ jïÀ jüÀ jıÀ kFÀ kpÀ kvÀ kÆÀ lÀ l]À lŠÀ lÀ lÜÀ m)À mXÀ m^À m¿À mÅÀ mÕÀ mÛÀ nÀ n[À nªÀ nÖÀ nãÀ näÀ o2À oJÀ oPÀ o’À o˜À oùÀ oÿÀ pÀ pÀ pNÀ p[À p\À p¥À p«À púÀ qÀ qÀ q`À qqÀ qwÀ q¯À qµÀ rÀ r%À r&À rrÀ r€À r†À rÕÀ rìÀ ròÀ s;À sLÀ sRÀ sŠÀ sÀ sñÀ sşÀ sÿÀ tMÀ tfÀ tlÀ t»À u
À uÀ u\À u©À uñÀ u÷À vFÀ vjÀ vpÀ vĞÀ vùÀ vúÀ wKÀ wdÀ wjÀ w³À w¹À xÀ xRÀ xxÀ x~À xÙÀ xßÀ xïÀ xõÀ yEÀ ynÀ y½À yîÀ yõÀ yöÀ zGÀ z`À zfÀ z¯À zÿÀ {,À {2À {À {“À {£À {©À {ëÀ |:À |PÀ |^À |_À |°À |ÉÀ |ÏÀ }À }À }gÀ }·À }ìÀ }òÀ ~OÀ ~UÀ ~eÀ ~kÀ ~¡À ~ïÀ =À FÀ GÀ ˜À ±À ·À € À €PÀ €}À €ƒÀ €åÀ €ëÀ €ûÀ À PÀ fÀ ±À ÊÀ ØÀ ÚÀ ÛÀ ‚3À ‚nÀ ‚rÀ ‚ÏÀ ƒÀ ƒÀ ƒoÀ ƒÃÀ „À „mÀ „qÀ „¿À „úÀ „şÀ …WÀ …[À …¨À …ğÀ †À †À †!À †%À †pÀ †©À †¿À †ÜÀ †÷À ‡À ‡5À ‡PÀ ‡eÀ ‡»À ‡ãÀ ‡äÀ ˆ(À ˆ.À ˆtÀ ˆ¹À ˆÁÀ ˆÂÀ ˆúÀ ‰ À ‰BÀ ‰qÀ ‰xÀ ‰yÀ ‰ÃÀ ‰ëÀ ‰ñÀ Š<À Š‰À ŠÒÀ ‹À ‹#À ‹SÀ ‹cÀ ‹iÀ ‹¸À ‹ìÀ ŒÀ ŒÀ ŒÀ Œ\À ŒiÀ ŒoÀ Œ½À ŒúÀ  À 'À -À À ÏÀ À  À MÀ UÀ WÀ XÀ |À €À À ’À ÇÀ 
À FÀ WÀ —À À îÀ RÀ XÀ ¦À ØÀ àÀ áÀ ‘À ‘"À ‘lÀ ‘¼À ’,À ’2À ’‚À ’§À ’°À ’±À ’ôÀ “9À “^À “dÀ “³À ”$À ”*À ”zÀ ”ŸÀ ”¥À ”óÀ •À •À •À • À •JÀ •NÀ •›À •ßÀ •ãÀ •ñÀ •õÀ –AÀ –MÀ –ˆÀ –ÅÀ –×À —À —À —|À —‚À —ÊÀ ˜À ˜&À ˜,À ˜<À ˜BÀ ˜À ˜¡À ˜òÀ ™+À ™4À ™5À ™jÀ ™pÀ ™×À ™İÀ š%À šuÀ šÀ š‡À š—À šÀ šëÀ šüÀ ›À ›À ›TÀ ›†À ›ŒÀ ›óÀ ›ùÀ œAÀ œ‘À œÀ œ£À œ³À œ¹À À À !À #À $À ^À bÀ yÀ µÀ ÊÀ À #À $À jÀ °À ×À ßÀ àÀ Ÿ$À ŸjÀ Ÿ±À ŸïÀ ŸùÀ ŸûÀ ŸüÀ  +À  7À  MÀ  SÀ  À  ïÀ  õÀ ¡AÀ ¡WÀ ¡¤À ¡ıÀ ¢RÀ ¢kÀ ¢sÀ ¢tÀ ¢ À ¢¦À ¢ÿÀ £0À £6À £vÀ £|À £ÔÀ ¤/À ¤5À ¤EÀ ¤KÀ ¤§À ¤ËÀ ¤×À ¤ØÀ ¤÷À ¤ıÀ ¥IÀ ¥OÀ ¥¢À ¥¨À ¥ïÀ ¥õÀ ¦JÀ ¦iÀ ¦ÀÀ ¦ÆÀ ¦ÖÀ ¦ÜÀ §$À §oÀ § À §ıÀ ¨
À ¨À ¨WÀ ¨]À ¨°À ©À ©+À ©1À ©ƒÀ ©ĞÀ ª"À ªtÀ ªzÀ ªÊÀ «À «hÀ «¸À «şÀ ¬À ¬À ¬À ¬hÀ ¬‚À ¬„À ¬…À ¬ÇÀ ¬ËÀ ­À ­0À ­DÀ ­ŒÀ ­¢À ­­À ­®À ­İÀ ­âÀ ®-À ®xÀ ®ÇÀ ¯À ¯dÀ ¯iÀ ¯¹À °
À °À ° À °hÀ °iÀ °ŠÀ °¦À °ÚÀ °ÛÀ ±À ±+À ±TÀ ±yÀ ±¤À ±ÍÀ ±÷À ²'À ²TÀ ²~À ²²À ²âÀ ³À ³À ³QÀ ³‡À ³ÅÀ ³ûÀ ´=À ´{À ´»À µÀ µMÀ µÀ µßÀ ¶)À ¶kÀ ¶lÀ ¶­À ¶ïÀ ¶ğÀ ·4À ·UÀ ·qÀ ·ŒÀ ·À ·»À ·şÀ ¸À ¸À ¸)À ¸TÀ ¸À ¸ÓÀ ¸ÔÀ ¹À ¹(À ¹.À ¹FÀ ¹_À ¹¦À ¹ªÀ ¹ÊÀ ºÀ ºDÀ ºkÀ º¯À º³À º´À ºìÀ »À »À »VÀ »\À »|À »‚À »’À »˜À »ŞÀ ¼À ¼WÀ ¼]À ¼¥À ¼ºÀ ¼ÎÀ ½À ½CÀ ½GÀ ½bÀ ½˜À ½ÖÀ ½ÚÀ ½ÛÀ ¾À ¾TÀ ¾UÀ ¾¡À ¾§À ¾éÀ ¿:À ¿‹À ¿¬À ¿²À ¿ÿÀ À À À&À ÀMÀ ÀSÀ ÀcÀ ÀiÀ À¸À ÀìÀ Á6À ÁLÀ ÁhÀ ÁµÀ ÁğÀ ÁôÀ ÂÀ ÂQÀ Â“À Â—À Â˜À ÂÜÀ ÂâÀ Ã
À Ã&À ÃxÀ Ã|À ÃŸÀ ÃÄÀ ÄÀ ÄÀ ÄÀ ÄAÀ ÄÀ ÄÍÀ ÄÓÀ ÅÀ Å+À ÅoÀ ÅsÀ Å•À Å·À ÅıÀ ÆÀ ÆÀ ÆCÀ ÆsÀ ÆyÀ Æ«À ÆÇÀ ÇÀ ÇÀ Ç@À ÇeÀ Ç§À Ç«À Ç¬À ÇíÀ ÇóÀ ÈDÀ ÈÀ È•À ÈÏÀ ÈÕÀ ÈóÀ ÈùÀ ÉbÀ ÉhÀ ÉÏÀ ÉÕÀ Ê<À ÊBÀ ÊÀ ÊßÀ ÊëÀ ÊñÀ ËÀ ËÀ ËVÀ Ë‚À ËËÀ Ì
À Ì(À Ì|À Ì€À Ì¥À ÌÊÀ ÍÀ ÍÀ ÍÀ ÍJÀ ÍÀ Í‚À ÍÍÀ ÎÀ ÎfÀ Î³À ÏÀ ÏÀ ÏLÀ ÏRÀ Ï À ÏÄÀ ÏÊÀ Ğ3À Ğ9À Ğ¢À Ğ¨À ÑÀ ÑÀ ÑcÀ Ñ´À ÑÀÀ ÑÆÀ ÑÖÀ ÑÜÀ Ò&À ÒAÀ ÒŠÀ ÒªÀ ÒóÀ Ò÷À ÓÀ Ó\À Ó§À Ó«À Ó¬À ÓüÀ Ô:À Ô@À ÔdÀ ÔƒÀ ÔÇÀ ÔèÀ ÔıÀ ÕÀ Õ>À Õ™À ÕàÀ ÕëÀ ÕñÀ ÖÀ ÖÀ Ö,À ÖEÀ Ö—À ÖßÀ ×'À ×4À ×À ×³À ØÀ Ø^À Ø¯À ØµÀ Ø¹À ØºÀ ÙÀ Ù`À Ù¬À Ù²À ÙÚÀ Ú'À ÚKÀ Ú¥À Ú©À ÚÔÀ ÚùÀ Û?À ÛCÀ ÛDÀ Û~À Û„À ÛºÀ ÛÀÀ ÛĞÀ ÛÖÀ ÜÀ ÜJÀ Ü|À ÜÄÀ ÜÛÀ İÀ İÀ İ-À İ=À İKÀ İzÀ İ±À İºÀ İÍÀ İ×À İçÀ ŞÀ Ş6À Ş–À Ş À Ş¨À Ş»À ŞÅÀ ŞıÀ ßÀ ßÀ ßIÀ ß[À ßaÀ ß†À ßŒÀ ßİÀ ßşÀ àUÀ àwÀ à{À à£À àéÀ á	À á'À áUÀ á]À ájÀ á°À á¶À áºÀ á»À áöÀ áüÀ âCÀ â]À âcÀ âqÀ âÀ â¸À âÊÀ âäÀ ã4À ã?À ãGÀ ãQÀ ãWÀ ãgÀ ãmÀ ã¨À ãÉÀ ä À äBÀ äFÀ änÀ ä‡À ä¥À äÓÀ äÛÀ äèÀ å)À åÀ åªÀ åîÀ åöÀ åüÀ æ À æÀ æ@À æFÀ æ’À æÜÀ çÀ ç'À çnÀ çrÀ ç“À çİÀ çáÀ çâÀ çîÀ èÀ è=À è\À èbÀ è’À è­À èÉÀ èòÀ éÀ é0À élÀ é{À éÀ é¦À éÏÀ éôÀ éüÀ ê(À êeÀ êºÀ êÄÀ êÓÀ êùÀ ëÀ ëÀ ëÀ ë7À ëhÀ ë€À ë†À ë¶À ëŞÀ ëöÀ ëüÀ ì-À ìYÀ ìqÀ ìwÀ ì–À ìÓÀ ìëÀ ìñÀ íÀ íJÀ íbÀ íhÀ í—À íØÀ íğÀ íöÀ îÀ îCÀ î[À îaÀ î€À î½À îÕÀ îÛÀ îóÀ ï,À ï2À ïIÀ ïgÀ ïkÀ ïmÀ ïnÀ ï¹À ï½À ğ À ğJÀ ğ•À ğÇÀ ğËÀ ğşÀ ñÀ ñ:À ñLÀ ñhÀ ñnÀ ñ»À ñçÀ ñíÀ ò À ò(À òuÀ òÃÀ òûÀ ó4À óDÀ óFÀ óGÀ ó‰À ó¡À óïÀ ô<À ô„À ôÎÀ ôåÀ ôüÀ õÀ õ`À õkÀ õlÀ õŒÀ õ’À õëÀ õşÀ õÿÀ öÀ ö"À örÀ ö­À ö¾À ö¿À öåÀ öëÀ ÷7À ÷dÀ ÷jÀ ÷À ÷…À ÷“À ÷±À ÷ÑÀ ÷×À øÀ ø=À ø“À øÕÀ øöÀ ùÀ ù*À ùDÀ ù^À ùiÀ ùqÀ ù{À ù‘À ù’À ù¤À ùªÀ ùúÀ úHÀ ú”À úáÀ û*À û0À ûÀ ûÀ û“À û£À û©À üÀ üMÀ üTÀ üVÀ üWÀ ü–À ü©À ü÷À ıGÀ ızÀ ı†À ı‡À ıÖÀ ş%À şXÀ şdÀ şeÀ şµÀ şüÀ ÿKÀ ÿ†À ÿ•À ÿ—À ÿ˜À ÿÄÀ ÿıÀ ÿşÀ 4À 8À xÀ |À ÊÀ âÀ æÀ5À„ÀËÀÀaÀoÀsÀ¿ÀÀUÀYÀgÀkÀÙÀ(ÀNÀÀ«ÀİÀíÀÀ(À2ÀQÀkÀoÀpÀ‘À­ÀÄÀÅÀÀ	ÀTÀ–À·ÀŞÀßÀÀ$ÀoÀ²ÀÓÀûÀüÀÀÀ\ÀoÀpÀ²ÀÆÀÇÀáÀ	.À	_À	eÀ	¶À	ÑÀ	×À
"À
mÀ
¼À
ÜÀ
ïÀ
À7ÀcÀyÀ°ÀÅÀèÀ ÀÀ
ÀÀOÀUÀ£À¹ÀÔÀèÀøÀÀ'À1ÀŸÀ£À¤ÀÙÀßÀ+À;ÀAÀ†ÀÕÀÀ"ÀoÀˆÀØÀ'ÀqÀ½ÀÀ?ÀmÀqÀrÀ®À´À ÀOÀ{ÀÀĞÀÀQÀÀÊÀèÀÀ:ÀHÀhÀvÀÀ­ÀûÀÀÀÀWÀyÀÀ¿ÀõÀÀ#ÀwÀŠÀ”À§À«À¬ÀİÀãÀ2ÀÀÒÀÀjÀ¸ÀÀ"À(ÀvÀŸÀ¥ÀíÀ>ÀTÀZÀÀ–À¤À¿ÀßÀ÷ÀıÀ5ÀtÀ“ÀİÀîÀ À ÀpÀ¾ÀäÀÀ%ÀFÀNÀTÀvÀªÀõÀ ÀcÀ§ÀäÀıÀÀ?ÀoÀuÀ’À¬À²ÀÔÀòÀ À À À 7À ZÀ `À {À À ¤À İÀ çÀ íÀ!À! À!*À!0À!uÀ!ÃÀ!çÀ!ùÀ"À"&À"QÀ"¢À"ğÀ#2À#;À#AÀ#`À#‹À#À#À#ÜÀ$"À$(À$uÀ$¿À%À%^À%¨À%õÀ&.À&/À&;À&eÀ&gÀ&hÀ&‚À&·À' À'À' À'nÀ'À'¬À'ºÀ'»À(
À($À(%À(uÀ(À(‘À(æÀ)/À)|À)¬À)ãÀ)ôÀ*À*À*)À*1À*5À*6À*rÀ*ÈÀ+!À+"À+<À+OÀ+gÀ+sÀ+‹À+ØÀ+ğÀ,:À,rÀ,yÀ,À,ŸÀ,£À,¤À,ïÀ-À-VÀ-rÀ-sÀ-œÀ-À-ãÀ.À.À.À.?À.AÀ.BÀ.\À.}À.±À.³À.´À.æÀ/"À/#À/WÀ/[À/—À/±À/µÀ/ÿÀ0HÀ0–À0ÜÀ1'À1PÀ1TÀ1À1‘À1À1©À1ãÀ2$À2BÀ2À2ÚÀ2÷À3CÀ3bÀ3ƒÀ3‰À3‘À3•À3«À3¯À3»À3ÈÀ4À4CÀ4ƒÀ4ÂÀ5À5(À5wÀ5¿À5àÀ5æÀ5îÀ6 À6JÀ6fÀ6lÀ6ªÀ6ÆÀ7À7À74À7:À7‡À7¢À7£À7ÌÀ7ÒÀ8À8 À8lÀ8À8ƒÀ8„À8¤À8¨À8ğÀ9
À9À9FÀ9cÀ9zÀ9 À9¶À9·À9æÀ9ìÀ: À:EÀ:`À:aÀ:‰À:À:ÓÀ:ÙÀ;*À;0À;qÀ;¡À;ÅÀ;ÆÀ<À<9À<?À<ŠÀ<¯À<ÁÀ<ÃÀ<ÄÀ=À=À=^À=yÀ=~À=·À=ÕÀ=éÀ=êÀ>À>À>À>LÀ>MÀ>¡À>ÁÀ>ÂÀ>áÀ>âÀ>îÀ?8À?9À?’À?·À?¸À?ÄÀ?ïÀ@7À@ŸÀ@ºÀ@İÀA>ÀAHÀAÀAÀA¸ÀAôÀB6ÀBBÀBJÀBRÀBkÀB‰ÀBÀB¬ÀB°ÀB±ÀBíÀC>ÀCÀCÀC›ÀCİÀCøÀCùÀDÀDfÀDhÀDiÀDŒÀDÀDßÀE/ÀE}ÀE ÀE¤ÀEöÀFDÀF_ÀFŸÀFÄÀGÀG[ÀG§ÀG÷ÀH
ÀHÀHYÀH£ÀHóÀIBÀIÀIßÀJ.ÀJvÀJ²ÀJ¶ÀK ÀKJÀKšÀKÖÀKÚÀL'ÀL3ÀLXÀLlÀL€ÀL•ÀL³ÀL¾ÀM
ÀM4ÀM@ÀM^ÀM~ÀM¢ÀM§ÀM©ÀMªÀMÍÀMÑÀN ÀNpÀN¾ÀNáÀNåÀO9ÀO‡ÀOÀÀOÄÀPÀPfÀPrÀPvÀPÁÀQÀQ[ÀQªÀQöÀRGÀR–ÀRŞÀSÀSÀShÀS²ÀTÀT>ÀTBÀTÀT›ÀTŸÀTÄÀTÈÀUÀUcÀU®ÀUÖÀVÀV!ÀV5ÀVJÀVhÀVmÀV•ÀV¡ÀVàÀVıÀWAÀWiÀWsÀWºÀWäÀWîÀWöÀX>ÀXEÀXJÀXLÀXMÀXpÀXtÀX¿ÀXÃÀYÀY_ÀYÀY¢ÀYëÀZ:ÀZPÀZTÀZ¢ÀZïÀ[;À[|À[ËÀ\À\kÀ\»À\òÀ\öÀ]@À]ŠÀ]¾À]ÂÀ^À^À^À^DÀ^HÀ^˜À^ãÀ_.À_VÀ_ƒÀ_ŸÀ_ÉÀ_ÔÀ_şÀ`JÀ`RÀ`­À`ìÀa-ÀaUÀazÀa¡Àa¨Àa¶ÀaÌÀaĞÀaÒÀaÓÀb#ÀbEÀbGÀbHÀb—ÀbÀÀbÄÀbÒÀbÖÀc ÀcAÀc}Àc“ÀcªÀc­Àc®ÀcóÀc÷ÀdÀd	ÀdUÀd“Àd»ÀdÓÀdÿÀeÀeTÀelÀeŸÀeËÀeùÀeúÀf(Àf.Àf}ÀfÍÀgÀghÀg“Àg™ÀgÏÀgãÀgäÀhÀhÀhiÀh¸ÀiÀiSÀi}ÀiƒÀi¹ÀiÎÀiÏÀiÛÀjÀjÀjÀjcÀjgÀj¶ÀkÀkKÀk•ÀkÂÀkÄÀkÅÀl#Àl\Àl–Àl³ÀlµÀl¶ÀlóÀl÷ÀmEÀmÀm¨Àm¬ÀmøÀnIÀnˆÀnŒÀn×Ào!ÀoqÀoÀÀpÀp]Àp¬ÀpôÀq0Àq4Àq~ÀqÈÀrÀrTÀrpÀr„Àr‘ÀrŸÀrµÀrØÀréÀrıÀsÀs0Às5ÀsRÀs†ÀsŠÀs¨ÀsŞÀsâÀsãÀtÀt0ÀtnÀt~Àt”Àt¬ÀtÈÀtåÀtîÀtïÀuÀuRÀu|Àu†ÀuÏÀuûÀvÀvÀvÀvÀv:Àv^Àv„ÀvÀv¬ÀvğÀwÀw'Àw2ÀwXÀwtÀw”Àw•ÀwÁÀwÍÀwÓÀwÕÀwÖÀx#Àx3Àx7ÀxnÀx‚ÀxÌÀxÒÀy#ÀyrÀyÁÀyìÀyòÀz*Àz5Àz6ÀzxÀz~ÀzÏÀ{ À{&À{_À{jÀ{lÀ{mÀ{‘À{•À{£À{§À{öÀ|À|1À|eÀ|kÀ|¹À}À}EÀ}KÀ}[À}aÀ}°À}ÊÀ}ØÀ~'À~MÀ~SÀ~¡À~ïÀ	ÀÀÀVÀcÀ®À´À€À€MÀ€‚À€‹À€ÖÀÀÀcÀ·À½ÀÍÀ‚
À‚À‚EÀ‚KÀ‚™À‚äÀƒ%Àƒ+Àƒ;ÀƒAÀƒŠÀƒ£Àƒ¸ÀƒºÀƒ»À„À„)À„yÀ„œÀ„¢À„òÀ…;À…ŒÀ…ÕÀ…ïÀ…õÀ†DÀ†À†ÊÀ†ĞÀ‡À‡@À‡RÀ‡TÀ‡UÀ‡­À‡÷ÀˆÀˆ-Àˆ.Àˆ:Àˆ‚ÀˆÀˆŸÀˆ ÀˆÒÀˆÖÀ‰À‰À‰bÀ‰¡À‰µÀ‰¹À‰ÿÀŠ*ÀŠ.ÀŠmÀŠ°ÀŠØÀŠÜÀ‹ À‹YÀ‹oÀ‹À‹À‹¸À‹¾ÀŒÀŒZÀŒ}ÀŒ±ÀŒáÀŒøÀŒüÀŒıÀ;ÀAÀ†À£ÀÇÀÈÀıÀ À!ÀiÀ–À—ÀŞÀëÀÀÀVÀˆÀµÀ¶ÀùÀ9ÀHÀNÀ¿À‘4À‘zÀ‘{À‘¾À’À’JÀ’WÀ’¥À’¦À’ëÀ“2À“AÀ“GÀ“´À”%À”wÀ”xÀ”½À•À•IÀ•^À•¸À•¹À•ÿÀ–CÀ–ˆÀ–ÏÀ–ôÀ–úÀ—gÀ—ØÀ˜À˜À˜eÀ˜©À˜îÀ™5À™{À™£À™ñÀ™òÀš5ÀšWÀš]Àš ÀšÄÀšÊÀ›À›QÀ›˜À›ÜÀœ#ÀœgÀœ•Àœ›ÀœàÀÀgÀhÀ·ÀüÀÀQÀšÀŞÀŸÀŸÀŸPÀŸŸÀŸëÀŸñÀ À 5À PÀ kÀ †À ŒÀ À ÜÀ¡!À¡'À¡[À¡aÀ¡°À¡şÀ¢AÀ¢‹À¢‘À¢ÔÀ£"À£oÀ£†À£¡À£»À£ÜÀ£÷À¤À¤-À¤3À¤4À¤{À¤’À¤­À¤®À¤ğÀ¥À¥$À¥vÀ¥ÄÀ¥ßÀ¥àÀ¦(À¦eÀ¦¤À¦åÀ§+À§oÀ§³À§¿À§ÅÀ¨1À¨¡À¨§À©À©‹À©ËÀ©ÌÀªÀª,Àª2ÀªÀª¦Àª¬ÀªóÀ«'À«(À«jÀ«­À«½À«ÛÀ«ÜÀ¬"À¬(À¬uÀ¬ÃÀ¬îÀ­0À­1À­wÀ­¶À­óÀ­ùÀ®FÀ®—À®ÂÀ¯À¯À¯QÀ¯’À¯¢À¯£À¯èÀ°,À°GÀ°WÀ°XÀ°¨À°õÀ±À±À±bÀ±hÀ±­À±ÌÀ±ÍÀ²À²<À²YÀ²ZÀ²šÀ²ÊÀ²ñÀ²òÀ³'À³-À³}À³ÊÀ´À´TÀ´ZÀ´«À´úÀµLÀµ™ÀµãÀ¶1À¶?À¶„À¶˜À¶™À¶åÀ¶øÀ¶şÀ·NÀ·œÀ·ÖÀ¸À¸KÀ¸œÀ¸¯À¸µÀ¹,À¹0À¹1À¹€À¹±À¹·ÀºÀºKÀºšÀºéÀ»3À»kÀ»qÀ»¼À¼	À¼RÀ¼†À¼ŒÀ¼ÜÀ½)À½yÀ½¼À¾	À¾VÀ¾¥À¾õÀ¿DÀ¿JÀ¿˜À¿çÀÀÀÀ!ÀÀrÀÀ½ÀÀ÷ÀÀùÀÀúÀÁDÀÁlÀÁÀÁ‘ÀÁßÀÂ$ÀÂ7ÀÂ8ÀÂqÀÂ‘ÀÂ’ÀÂÙÀÂÿÀÃ ÀÃÀÃPÀÃ\ÀÃÀÃÀÃòÀÄÀÄÀÄlÀÄ˜ÀÄ™ÀÄ¥ÀÅÀÅ/ÀÅ0ÀÅ<ÀÅ¢ÀÅØÀÅÙÀÅåÀÆCÀÆoÀÆpÀÆ|ÀÆâÀÇÀÇÀÇ%ÀÇÀÇíÀÇîÀÇúÀÈ{ÀÈ¦ÀÈÙÀÈÚÀÈæÀÉeÀÉÀÀÉÁÀÉÍÀÊTÀÊ·ÀÊ¸ÀÊÄÀË;ÀËŠÀË‹ÀË—ÀÌÀÌmÀÌnÀÌzÀÌÌÀÌìÀÍKÀÍOÀÍPÀÍÓÀÎYÀÎZÀÎfÀÎ‰ÀÎªÀÎÅÀÎàÀÎûÀÏÀÏ&ÀÏJÀÏ¤ÀÏ¨ÀÏ©ÀĞ/ÀĞ¼ÀĞ½ÀĞÉÀĞäÀĞşÀÑÀÑ:ÀÑUÀÑpÀÑwÀÑ ÀÑÄÀÒ0ÀÒ4ÀÒ5ÀÒÃÀÒèÀÒşÀÓÀÓ*ÀÓ@ÀÓWÀÓlÀÓƒÀÓ„ÀÓÀÓ¬ÀÓÌÀÔÀÔÀÔÀÔ|ÀÔÌÀÔÍÀÔÙÀÔõÀÕÀÕQÀÕUÀÕVÀÕÅÀÖÀÖÀÖ"ÀÖcÀÖƒÀÖÖÀÖÚÀÖÛÀ×YÀ×ÎÀ×ÏÀ×ÛÀØÀØBÀØFÀØGÀØ™ÀØÖÀØ×ÀØãÀÙÀÙ$ÀÙHÀÙLÀÙMÀÙ—ÀÙÅÀÙÆÀÙÒÀÚÀÚ9ÀÚTÀÚ|ÀÚÊÀÚ×ÀÛÀÛÀÛÀÛÀÛ}ÀÛ¿ÀÛÀÀÜ2ÀÜ’ÀÜ“ÀÜŸÀÜéÀİÀİ(ÀİPÀİ¤Àİ±ÀİóÀİùÀİıÀİşÀŞeÀŞ®ÀŞ¯Àß'ÀßÀßÀßšÀßçÀà ÀàÀàÀàZÀàsÀàtÀà€Àà ÀàÃÀàíÀàñÀàòÀáRÀáÀá‚ÀáÀá¬ÀáĞÀáşÀâ&Àâ7Àâ;Àâ<Àâ“ÀâÏÀâĞÀâÜÀãÀã*ÀãXÀãwÀãˆÀãŒÀãÀãàÀäÀä Àä,ÀäAÀälÀäªÀä®Àä¯ÀäôÀåÀåÀå{ÀåÅÀåÆÀåÒÀæÀæ:Àæ>Àæ?ÀæKÀæjÀælÀæmÀæ¯Àæ³ÀæÁÀçÀç/Àç`ÀçfÀçŒÀç¹ÀçºÀçÿÀèÀèZÀè†ÀèÃÀéÀéÀéÀé/Àé5ÀéˆÀéÌÀéåÀéæÀêÀêÀêjÀê¼ÀêØÀêïÀêğÀë Àë&ÀëvÀëÅÀëáÀëçÀì5Àì„ÀìÓÀí!Àí2ÀíwÀí°Àí²Àí³ÀíûÀíÿÀîPÀîœÀîâÀîæÀï,Àï0Àï|ÀïËÀïéÀïíÀğ7Àğ‡Àğ¨ÀğèÀñÀñmÀñnÀñ–Àñ—Àñ£ÀñÕÀñ×ÀñØÀò'ÀòAÀò|Àò§Àò¨ÀòÃÀòæÀòçÀòóÀóÀóAÀóbÀózÀóİÀô9Àô­Àô¶Àô¼ÀôÖÀôÚÀôÛÀôçÀôûÀõ"ÀõRÀõeÀõkÀõƒÀõ•Àõ™Àõ›ÀõœÀõÛÀõßÀö'ÀörÀöÀÀöäÀöèÀ÷6À÷…À÷ÑÀø!ÀøoÀø}ÀøÀø®ÀøìÀù.ÀùaÀùbÀù˜ÀùÀùçÀú1ÀúzÀú‘Àú’Àú·Àú½ÀûÀûQÀû¡ÀûÀÀû×ÀûØÀüÀü	ÀüYÀü ÀüîÀı=ÀıvÀı|ÀıÊÀşÀşiÀş¢Àş¼Àş½ÀşÜÀşİÀÿ-ÀÿTÀÿZÀÿ©ÀÿöÀ À À IÀ OÀ •À ÇÀÀÀÀVÀ\ÀÀâÀ0ÀÀ‘À’ÀÀÀÀ	ÀDÀyÀÀ¢À£ÀøÀ:À;À_ÀÕÀ÷ÀûÀüÀ]ÀŠÀ‹ÀÏÀÿÀMÀÀËÀçÀúÀÀÀCÀhÀqÀwÀ{À|À×ÀÀÀ]À„ÀúÀ	(À	kÀ	|À	€À	À	ñÀ
_À
`À
„À
úÀÀ"À#ÀÀ®À¯ÀÚÀßÀ4À^ÀvÀ¢À²ÀÏÀÕÀæÀêÀëÀEÀkÀlÀ¸À¾ÀÿÀÀ!À"ÀWÀ“À¤ÀÜÀİÀ*ÀmÀwÀxÀÆÀÀ@ÀIÀJÀ—ÀèÀ+À4À5À…À“ÀœÀÀŸÀìÀ<ÀNÀRÀ£À¶ÀÀÀ;ÀAÀ’À˜ÀçÀ5À…À–ÀœÀëÀñÀÀÀ-À3À€À™ÀªÀ»ÀÀÀÁÀÛÀòÀóÀ9À„À®ÀäÀåÀñÀÀ3ÀUÀxÀ|À}À‰À¼À½ÀÉÀÀÀÀnÀ½ÀÀWÀˆÀŒÀÕÀâÀÀZÀ«ÀïÀõÀFÀ”ÀÁÀüÀÀ4ÀLÀhÀiÀ³ÀúÀÀÀbÀŠÀÀÃÀöÀ)À\ÀÀ•ÀäÀ0À6ÀDÀ„À›À²ÀÉÀàÀêÀôÀúÀ À À 3À 9À GÀ …À ¡À ½À ÙÀ õÀ ÿÀ!	À!À!–À!œÀ!ªÀ!çÀ"
À"-À"PÀ"sÀ"}À"‡À"À#À#À#*À#kÀ#‘À#·À#İÀ$À$À$À$GÀ$^À$yÀ$“À$±À$²À$şÀ%À%6À%MÀ%hÀ%€À%©À%ªÀ%øÀ&À&;À&RÀ&mÀ&…À&®À&¯À&ÆÀ&åÀ'À'À'À'HÀ'}À'ÁÀ(
À(SÀ(TÀ(lÀ(xÀ(ÅÀ(ÆÀ(ïÀ)À)À)OÀ)fÀ)pÀ)˜À)±À)ßÀ)ıÀ*À*À*iÀ*“À*·À*ìÀ+À+EÀ+TÀ+–À+œÀ+ À+¡À+­À+ĞÀ+üÀ,À,À,6À,VÀ,À,¯À,ÚÀ,ŞÀ,ßÀ,ëÀ- À-*À-À-‘À-’À-À-¿À-ÔÀ-ëÀ.$À.=À.lÀ.À.ÂÀ.æÀ/À/'À/LÀ/RÀ/VÀ/WÀ/cÀ/yÀ/À/¥À/ŞÀ/÷À0&À0JÀ0|À0 À0ÒÀ0áÀ1}À1ƒÀ1‡À1‰À1ŠÀ1ÈÀ1ÌÀ2À2gÀ2¹À2ÏÀ3
À3,À3dÀ3xÀ3¹À3½À3¾À3âÀ4À40À4iÀ4mÀ4œÀ4áÀ4õÀ5À5À5À5GÀ5ŒÀ5 À5¾À5ÂÀ5ÃÀ6À67À6TÀ6UÀ6•À6µÀ6¶À7À7PÀ7QÀ7¤À7ÕÀ7ÖÀ8:À8dÀ8eÀ8ÉÀ8óÀ8õÀ8öÀ9)À9-À9;À9?À9À9ÛÀ:*À:RÀ:À:ÉÀ:æÀ;8À;eÀ;fÀ;¢À<À<jÀ<nÀ<oÀ<¼À=À=QÀ=”À=˜À=™À=İÀ>/À>}À>¿À>ÃÀ>ÄÀ?À?À?\À?¦À?ØÀ@$À@DÀ@‚À@ˆÀ@êÀ@îÀ@ïÀA9ÀA?ÀAÀAÅÀAêÀBFÀBÀB’ÀB“ÀBäÀC1ÀCXÀCYÀC¢ÀCÚÀCúÀCüÀCıÀD/ÀDzÀD{ÀD•ÀDºÀD»ÀDÜÀE ÀE,ÀEcÀEdÀEpÀE³ÀE´ÀEÀÀFÀFÀFÀF4ÀF`ÀFtÀFzÀF¡ÀFÑÀGÀGÀGÀGÀG\ÀG^ÀG_ÀG—ÀGûÀGüÀHÀH*ÀHEÀHFÀHZÀHœÀH¨ÀHßÀHàÀHûÀIÀI>ÀIkÀIœÀIÇÀIÍÀIÑÀIÒÀIŞÀJ(ÀJ)ÀJ5ÀJ€ÀJÀJÀJ°ÀJÜÀJğÀJöÀK#ÀKEÀKgÀKÀK’ÀK“ÀKŸÀKÒÀKÔÀKÕÀLÀLOÀLPÀLhÀL€ÀLÀLÅÀLÑÀMÀM	ÀMÀMUÀMVÀMbÀM£ÀM¤ÀM°ÀMÓÀMÿÀNÀNÀN@ÀNdÀN‰ÀNÀNÀNšÀNÏÀNÑÀNÒÀOÀOJÀOKÀOcÀO{ÀO|ÀO¿ÀOËÀPÀPÀPÀPNÀPOÀP[ÀP›ÀPœÀP¨ÀPËÀP÷ÀQÀQÀQ7ÀQ[ÀQ€ÀQ„ÀQ…ÀQ‘ÀQÆÀQÈÀQÉÀQüÀRMÀRNÀRoÀRÀR‘ÀR«ÀRñÀRıÀS4ÀS5ÀSAÀS«ÀS¬ÀS¸ÀTÀTÀTÀT>ÀTjÀT~ÀT„ÀT¬ÀTØÀUÀU	ÀU
ÀUÀUSÀUUÀUVÀU•ÀU™ÀUéÀV<ÀV€ÀV»ÀV÷ÀW,ÀWEÀWYÀWÀW¡ÀW¢ÀWïÀX5ÀXfÀXÀX“ÀXÄÀXÈÀXÉÀYÀY_ÀYÀY§ÀY»ÀYëÀYïÀYğÀZ4ÀZ:ÀZˆÀZÒÀ[À[À[@À[~À[„À[˜À[ÒÀ[ÖÀ[×À\	À\<À\UÀ\iÀ\¯À\ÓÀ\×À\ØÀ]À]?À]XÀ]lÀ]ÂÀ^À^QÀ^UÀ^VÀ^–À^¶À^·À_%À_lÀ_mÀ_ÖÀ`À`À`|À`¸À`¹ÀaÀaXÀaYÀa¸ÀaõÀaöÀbfÀb¹ÀbºÀcÀc.ÀcKÀcMÀcNÀc”ÀcÉÀcşÀdHÀddÀd€ÀdÀdÀd®Àd¯ÀdØÀdŞÀe/ÀeJÀebÀerÀe“Àe¦Àe°ÀeÅÀeÉÀeÊÀfÀf=ÀfCÀfÀfÚÀg#ÀgmÀgsÀg¸ÀgËÀgÛÀgúÀhÀh*Àh4Àh8Àh:Àh;ÀhÀh©Àh­ÀhúÀiHÀi•ÀiåÀiéÀj>Àj’ÀjëÀkCÀk–Àk¿ÀkÃÀlÀlBÀlFÀlTÀlXÀlœÀlæÀm6Àm`ÀmªÀmòÀnÀnfÀn´ÀnÎÀo	ÀoÀosÀoyÀoÅÀpÀpÀpiÀp‰ÀpÀpòÀqUÀq·ÀqÀÀqÁÀrÀrÀrpÀrÎÀrúÀs ÀsZÀs·Às½Àt#Àt‰ÀtîÀtúÀtûÀuNÀuTÀu¬ÀvÀvZÀvuÀv{ÀvÕÀw+Àw@ÀwFÀwªÀxÀxqÀx{Àx|Àx¼ÀxÂÀyÀywÀy‡ÀyÀyæÀzÀzÀzoÀzÒÀ{4À{=À{?À{@À{qÀ{™À{ËÀ{ôÀ|À|À|*À|,À|-À|aÀ|‰À|ÃÀ|ìÀ}
À}-À}QÀ}tÀ}“À}²À}¶À}ÇÀ}ÉÀ}ÊÀ~À~)À~KÀ~xÀ~‘À~ªÀ~ÃÀ~ÜÀ~íÀ~ïÀ~ğÀ8À<ÀÀ¡À¥À³À·À€-À€1À€VÀ€‹À€‘À€àÀ1À{ÀÊÀ‚À‚lÀ‚¼À‚ŞÀ‚äÀƒ3ÀƒiÀƒoÀƒÒÀ„5À„™À„ÿÀ…À…PÀ…–À…±À…·À†À†WÀ†—À†ªÀ†»À†ÊÀ†äÀ‡À‡*À‡DÀ‡iÀ‡ŒÀ‡ÈÀ‡ÛÀˆÀˆLÀˆ‰ÀˆñÀ‰À‰`À‰dÀ‰eÀ‰°À‰ĞÀ‰ÖÀŠ%ÀŠvÀŠÀÀ‹À‹`À‹±ÀŒÀŒ#ÀŒ)ÀŒwÀŒ­ÀŒ³ÀÀyÀİÀCÀIÀšÀàÀûÀÀNÀ¡ÀáÀçÀ3ÀÀËÀ‘À‘hÀ‘À‘ À‘³À‘ÆÀ‘àÀ‘şÀ’&À’@À’SÀ’pÀ’—À’ÓÀ’æÀ“À“PÀ“¸À“¹À”À”zÀ”¾À”ÔÀ•>À•KÀ•´À•ÊÀ–VÀ–\À–`À–aÀ–±À–ÏÀ–ÕÀ— À—nÀ—©À—¯À—şÀ˜OÀ˜™À˜èÀ™9À™ŠÀ™ÚÀ™üÀšÀšRÀš“Àš™ÀšûÀ›]À›ÀÀœ%Àœ+ÀœzÀœÊÀœíÀœóÀ@À“ÀÓÀåÀøÀÀ0ÀXÀuÀ˜À²ÀÙÀÿÀŸ;ÀŸNÀŸ{ÀŸ¸À  À 4À ©À ­À ®À ëÀ¡À¡À¡{À¡şÀ¡ÿÀ¢~À¢›À¢±À¢ÇÀ¢ÜÀ¢ôÀ£À£'À£DÀ£EÀ£åÀ¤À¤À¤-À¤GÀ¤ZÀ¤mÀ¤…À¤À¤¼À¤ĞÀ¤íÀ¤îÀ¥tÀ¥À¥¦À¥¼À¥ÔÀ¥óÀ¦À¦ À¦7À¦SÀ¦TÀ¦wÀ¦­À¦ËÀ¦ëÀ§CÀ§KÀ§XÀ§ˆÀ§äÀ§ìÀ§òÀ§öÀ§øÀ§ùÀ¨7À¨_À¨…À¨‹À¨ÇÀ©À©\À©À©”À©äÀª3ÀªAÀªGÀªÀªÔÀ«À«À«MÀ«À«êÀ¬À¬#À¬qÀ¬“À¬šÀ¬¼À¬ÌÀ¬ìÀ­*À­0À­DÀ­·À­ĞÀ­îÀ­ôÀ­øÀ­ùÀ®À®À®-À®=À®AÀ®BÀ®‚À®¢À®£À¯À¯À¯À¯ÛÀ° À°HÀ°dÀ°fÀ°gÀ°±À°ÆÀ°ÊÀ°ôÀ±DÀ±‚À±À±ÎÀ±âÀ²À²3À²RÀ²XÀ²hÀ²…À²˜À²¢À²¦À²§À²½À²¾À³À³	À³RÀ³—À³äÀ³úÀ´8À´}À´ÆÀµÀµ=Àµ…ÀµÇÀµâÀ¶À¶À¶OÀ¶À¶ÊÀ¶àÀ¶èÀ¶ìÀ¶íÀ·&À·yÀ·ÆÀ¸À¸eÀ¸zÀ¸¸À¸ÛÀ¸ÜÀ¹À¹\À¹ªÀ¹ÖÀºÀº1Àº?ÀºEÀºFÀº‚ÀºŸÀºĞÀºÖÀºÚÀºÛÀº÷À»À»À»3À»MÀ»NÀ»’À»²À»³À¼À¼BÀ¼CÀ¼wÀ¼ËÀ¼ÍÀ¼ÎÀ½À½À½:À½‚À½ÒÀ¾ À¾FÀ¾JÀ¾—À¾äÀ¿2À¿{À¿´À¿ßÀÀHÀÀdÀÀsÀÀ•ÀÀ²ÀÀ¹ÀÀ½ÀÀ¾ÀÀÚÀÀÛÀÁÀÁGÀÁHÀÁ|ÀÁ‚ÀÁĞÀÂÀÂiÀÂ·ÀÃÀÃ1ÀÃ7ÀÃ~ÀÃ„ÀÃ’ÀÃ®ÀÃĞÀÃïÀÄ
ÀÄÀÄÀÄhÀÄrÀÄxÀÄ†ÀÄ×ÀÅÀÅ3ÀÅdÀÅjÀÅÀÅèÀÆ3ÀÆ~ÀÆÉÀÆÏÀÆöÀÇ ÀÇ(ÀÇ2ÀÇ8ÀÇ…ÀÇÚÀÇëÀÇñÀÈ;ÀÈfÀÈ»ÀÈ×ÀÈÛÀÈÜÀÉÀÉÀÉpÀÉ³ÀÉ¹ÀÊÀÊ'ÀÊXÀÊ¬ÀÊ×ÀÊÛÀÊÜÀËÀË$ÀËsÀË¿ÀËúÀÌÀÌÀÌ.ÀÌPÀÌ`ÀÌdÀÌeÀÌÊÀÍ0ÀÍ1ÀÍœÀÍÙÀÍÚÀÎ6ÀÎ[ÀÎ\ÀÎ¯ÀÎËÀÎÍÀÎÎÀÏÀÏ#ÀÏFÀÏƒÀÏ•ÀÏİÀÏêÀÏëÀĞ9ÀĞJÀĞKÀĞœÀĞ±ÀĞ·ÀÑÀÑ@ÀÑÀÑÀÑ’ÀÑ“ÀÑËÀÑÏÀÒÀÒdÀÒ¯ÀÒûÀÓKÀÓqÀÓuÀÓÂÀÔÀÔ_ÀÔoÀÔsÀÔ¿ÀÕÀÕ]ÀÕªÀÕ÷ÀÖGÀÖ–ÀÖãÀÖşÀ×À×OÀ×™À×æÀØÀØÀØ[ÀØ ÀØíÀÙ>ÀÙÀÙßÀÚÀÚ9ÀÚ€ÀÚ†ÀÚÔÀÛ!ÀÛoÀÛºÀÛéÀÛïÀÜ<ÀÜeÀÜkÀÜ¼Àİ
ÀİYÀİ–Àİ´ÀİºÀŞ	ÀŞXÀŞ^ÀŞ°ÀŞÙÀŞßÀß/Àß€ÀßÑÀàÀàkÀà¶ÀáÀáÀáÀáeÀáÀá•ÀáÓÀáÙÀâ%ÀâvÀâÇÀãÀã:ÀãFÀã[ÀãyÀã’Àã¸ÀãĞÀã×ÀäÀäaÀägÀä¾ÀåÀåÀå6ÀåvÀå¨ÀåÇÀæÀæZÀæ¥Àæ²Àæ¼ÀæÄÀæÊÀçÀç`ÀçÀç›ÀçÏÀçğÀçşÀè5ÀèZÀèhÀèiÀèÙÀéÀé!Àé%Àé&ÀéwÀé¦Àé¬ÀéúÀêGÀê•ÀêàÀëÀëÀëbÀë¬ÀëøÀìGÀìZÀì`Àì±Àí ÀíGÀí˜ÀíéÀî8ÀîoÀîuÀîÄÀïÀïdÀï­ÀïæÀïìÀğ<ÀğÀğŞÀñ.ÀñxÀñÄÀòÀòBÀòHÀò–ÀòæÀó5ÀócÀóiÀó§Àó·ÀóÌÀóéÀô Àô%Àô>ÀôEÀôjÀôÚÀôàÀõ#ÀõnÀõtÀõËÀö"Àö(ÀöCÀöƒÀö¹ÀöØÀ÷$À÷pÀ÷»À÷ÈÀ÷ÒÀ÷ÚÀ÷àÀø4ÀøvÀø|Àø€ÀøÀøãÀùÀù=ÀùqÀù¯ÀùßÀúÀúÀúcÀú†Àú™Àú±ÀúÁÀúÙÀúìÀúöÀûÀû
ÀûÀûVÀû{ÀûÀÀûÜÀûİÀû÷ÀüAÀüGÀü•Àü«ÀüÆÀüÚÀüêÀıÀıÀı#Àı”Àı˜ÀıšÀı›ÀıéÀıíÀş)ÀşmÀş~Àş Àş¦ÀşôÀÿ>ÀÿwÀÿ}ÀÿÊÀ À /À 9À :À tÀ zÀ ÀÀ ÆÀÀÀ'À(À^ÀdÀ¦À¼ÀÇÀÉÀÊÀÀ À$ÀCÀQÀ‰À—À˜ÀÑÀŞÀàÀáÀÀÀaÀ¥ÀæÀêÀ3ÀƒÀÌÀéÀíÀ=À†À»À¿ÀÀKÀcÀ¦ÀÄÀÊÀÀ[À«ÀúÀGÀŠÀÀ×ÀíÀ	=À	>À	†À	ŒÀ	¸À	¾À	ÎÀ	ÔÀ
%À
ZÀ
iÀ
jÀ
»ÀÀ[À¤À³À¹ÀÀVÀ¤ÀìÀ:À„ÀŠÀ×ÀİÀÀÀUÀ¡ÀñÀAÀfÀlÀºÀÀTÀ¢ÀğÀ@ÀˆÀµÀ»ÀÀÀ$À2À_À‡ÀÀŞÀÀ>ÀwÀ‘À«À³À½ÀÃÀÀ`À®ÀÌÀÒÀàÀÀPÀxÀÀÏÀÀ?ÀYÀaÀkÀqÀÂÀÀRÀXÀfÀ“ÀªÀşÀ7ÀQÀhÀÉÀÀÀ$À.À4ÀÀÈÀÀQÀWÀ{ÀÀÀÀÆÀÀbÀ³ÀşÀMÀ›ÀæÀ1À‚ÀÓÀîÀôÀÀ
ÀZÀ|ÀÄÀÚÀÀÀHÀgÀmÀ¬À²ÀûÀ ?À QÀ RÀ ®À ûÀ!MÀ!SÀ!’À!˜À!æÀ"6À"XÀ"zÀ"{À"¾À#À#JÀ#À#…À#ªÀ#ÀÀ#ÁÀ$À$aÀ$‰À$ŠÀ$ÙÀ%#À%4À%:À%€À%’À%¹À%ºÀ&À&.À&/À&€À&ÌÀ'À'DÀ'gÀ'hÀ'¸À'óÀ(À(À(nÀ(ÄÀ(àÀ(æÀ)8À)†À)ÖÀ*À*!À*"À*pÀ*‡À*À*ãÀ*éÀ+-À+3À+…À+ÍÀ+öÀ+üÀ,FÀ,ZÀ,µÀ,¶À-À-#À-)À-€À-†À-ÊÀ-ĞÀ."À.jÀ.ºÀ.ôÀ.õÀ/CÀ/WÀ/]À/³À/¹À/ıÀ0À0UÀ0À0ÆÀ0ıÀ0şÀ1OÀ1¡À1ôÀ2À2À2_À2²À3À3SÀ3¢À3õÀ4HÀ4—À4èÀ5À5
À5BÀ5”À5èÀ67À6yÀ6À6ÍÀ6ôÀ6úÀ7À7)À7HÀ7À7¾À7İÀ8À8SÀ8bÀ8jÀ8tÀ8zÀ8ËÀ9À9rÀ9ÆÀ9ÖÀ9ÜÀ:"À:oÀ:£À:©À:ùÀ;HÀ;”À;¬À;ÁÀ;ŞÀ;ßÀ<0À<‚À<ÕÀ<ÛÀ=+À=}À=ÍÀ>À>oÀ>ÃÀ?À?#À?)À?^À?À?‚À?ÅÀ@À@.À@bÀ@cÀ@²À@úÀA ÀANÀATÀA¿ÀB.ÀBbÀBcÀB’ÀB˜ÀBİÀBøÀCÀCÀChÀC£ÀC©ÀDÀDƒÀD¬ÀD­ÀDşÀE@ÀEFÀE²ÀF"ÀFNÀFOÀFŸÀFïÀGÀGÀG`ÀGšÀG›ÀGèÀH9ÀH\ÀHbÀHÍÀI<ÀIeÀIfÀI±ÀJÀJRÀJuÀJ{ÀJèÀKYÀK’ÀK“ÀKÏÀKÕÀLÀLbÀL¬ÀM ÀMQÀM¡ÀMÍÀMÓÀNBÀNµÀN»ÀOÀOqÀOrÀO§ÀO­ÀOöÀP?ÀPkÀP”ÀP•ÀPãÀQ:ÀQuÀQvÀQÅÀRÀRÀRfÀRÀR…ÀRÑÀSÀS-ÀSqÀSrÀS¹ÀS¿ÀTÀT[ÀT¨ÀTõÀU8ÀU>ÀUŒÀUÙÀV'ÀVnÀVÀVÆÀVÇÀWÀW'ÀWLÀWMÀW™ÀW©ÀW¯ÀWúÀXÀXÀXYÀX¦ÀXäÀXêÀY9ÀY…ÀY‹ÀYÜÀZ)ÀZvÀZ|ÀZÆÀ[À[_À[™À[šÀ[ßÀ[åÀ\,À\2À\xÀ\ÂÀ\ÈÀ\ØÀ\ŞÀ].À]GÀ]‘À]’À]×À]İÀ^-À^zÀ^€À^ÆÀ_À_À_&À_,À_zÀ_˜À_äÀ_åÀ`/À`5À`À`’À`˜À`áÀa2ÀaIÀaOÀa˜ÀaæÀb2ÀbzÀbÊÀcÀc`Àc¯ÀcüÀdFÀd€Àd†Àd­Àd³ÀdÃÀeÀe`Àe‡ÀeÙÀf#Àf$ÀfhÀfnÀf¿ÀgÀgkÀg¿Àg÷ÀgıÀhMÀhÀhíÀi?ÀiÀiãÀj/Àj5Àj†ÀjÖÀk+Àk‚Àk²ÀlÀlTÀl˜ÀlÀlñÀm@Àm‹ÀmÙÀn.Àn4ÀnˆÀnÙÀo"Ào(ÀoyÀo”ÀošÀo¨Ào½ÀoæÀoùÀpÀpÀpÀpLÀp‚ÀpˆÀpáÀpÿÀq Àq&Àq8ÀqgÀqˆÀq¿ÀqóÀrÀr<ÀrXÀr•Àr³ÀrÑÀsÀsEÀssÀs„Às™ÀsÍÀtÀt7ÀtAÀtGÀtVÀt^ÀthÀtnÀtÇÀtÍÀtÛÀtğÀu4ÀuGÀu^ÀuqÀuŠÀu’Àu˜ÀuÆÀuüÀvÀv[ÀvyÀvšÀv Àv²ÀváÀwÀw9ÀwmÀw—ÀwÂÀwŞÀxÀx9ÀxWÀxÀxËÀxùÀy
ÀyÀySÀy–Ày¬ÀyàÀzÀz@ÀzJÀzPÀz_ÀzgÀzqÀzwÀzÀÀ{À{>À{DÀ{TÀ{ZÀ{¨À{¿À{İÀ|À|/À|UÀ||À|À|¼À|½À}À}À}XÀ}±À~À~XÀ~ªÀ~üÀ3À9À‰ÀÑÀ×À€(À€hÀ€“À€™À€çÀ1À7ÀƒÀĞÀ‚ À‚&À‚À‚’À‚˜À‚¦À‚»À‚äÀ‚÷ÀƒÀƒÀƒÀƒJÀƒ€Àƒ†ÀƒßÀƒıÀ„À„$À„6À„eÀ„µÀ…À…UÀ…qÀ…¶À† À†8À†cÀ†™À†ÂÀ†éÀ‡À‡AÀ‡GÀ‡ À‡ûÀˆUÀˆ—ÀˆÃÀˆïÀ‰.À‰mÀ‰yÀ‰šÀ‰øÀŠÀŠÀŠÀŠÀŠ)ÀŠ/ÀŠˆÀŠÀŠœÀŠ±ÀŠõÀ‹À‹À‹2À‹KÀ‹SÀ‹YÀ‹‡À‹½À‹ÃÀŒÀŒ:ÀŒ[ÀŒaÀŒsÀŒ¢ÀŒòÀAÀ’À®ÀóÀ=À{À³ÀŞÀÀ=ÀdÀ”À¼ÀÂÀÀtÀÏÀ‘,À‘wÀ‘½À‘æÀ’ À’;À’WÀ’sÀ’·À’ãÀ“À“À“UÀ“ŒÀ“ÁÀ“öÀ“üÀ”VÀ”°À•À•OÀ•~À•ŠÀ•«À–À–#À–)À–8À–@À–JÀ–PÀ–`À–fÀ–³À–ÈÀ–éÀ—À—?À—fÀ—À—´À—ÖÀ—×À˜$À˜*À˜zÀ˜À˜•À˜»À™À™À™À™cÀ™¤À™ÄÀš!Àš'Àš[ÀšzÀš™ÀšõÀšùÀšúÀ›dÀ›ÙÀ›ÚÀœ6Àœ’Àœ×ÀœüÀœıÀ	ÀWÀoÀpÀ“À«ÀÇÀğÀÀBÀkÀtÀzÀ‹ÀÀÀœÀÊÀäÀŸ ÀŸ-ÀŸQÀŸ¶ÀŸ¼ÀŸÀÀŸÁÀ #À }À ~À óÀ¡vÀ¡wÀ¡ƒÀ¡ÔÀ¡ïÀ¡ğÀ¡üÀ¢[À¢†À¢‡À¢“À¢êÀ£	À£
À£À£yÀ£ªÀ£«À£·À£öÀ£÷À¤VÀ¤„À¤…À¤‘À¤éÀ¥À¥À¥À¥|À¥¨À¥©À¥µÀ¥İÀ¥ıÀ¦;À¦AÀ¦ZÀ¦^À¦_À¦¬À¦İÀ¦ŞÀ¦êÀ§	À§:À§VÀ§jÀ§nÀ§oÀ§¿À§óÀ§ôÀ¨ À¨\À¨|À¨–À¨ãÀ©1À©sÀ©ËÀ©ÏÀ©ĞÀªOÀª¾Àª¿ÀªËÀ«À«(À«ZÀ«^À«_À«²À«óÀ«ôÀ¬ À¬8À¬iÀ¬mÀ¬nÀ¬ÇÀ­À­À­À­1À­`À­À­ÇÀ­ËÀ­ÌÀ®"À®[À®\À®hÀ®ŒÀ®»À®âÀ¯(À¯,À¯-À¯‰À¯ÈÀ¯ÉÀ¯ÕÀ°
À°8À°<À°=À°ŸÀ°ÕÀ°ÖÀ°âÀ±À±7À±WÀ±ŸÀ±£À±¤À²À²À²‘À²À²½À²êÀ²îÀ²ïÀ³DÀ³‘À³’À³À³ÈÀ³èÀ´À´@À´œÀ´¢À´¦À´§ÀµÀµÀµÀµªÀµ×ÀµùÀ¶;À¶?À¶@À¶À¶ıÀ¶şÀ·
À·EÀ·gÀ·‰À·áÀ·åÀ·æÀ¸LÀ¸ÀÀ¸ÁÀ¸ÍÀ¸÷À¹À¹1À¹oÀ¹ËÀ¹ÑÀ¹ÕÀ¹ÖÀºJÀºÌÀºÍÀºÙÀ»À»2À»tÀ»xÀ»yÀ»çÀ¼XÀ¼YÀ¼eÀ¼ÄÀ¼äÀ½`À½dÀ½eÀ½îÀ¾À¾À¾-À¾AÀ¾VÀ¾oÀ¾ˆÀ¾À¾ÁÀ¾ÜÀ¾İÀ¾éÀ¿À¿TÀ¿XÀ¿YÀ¿¼ÀÀÀÀÀÀ'ÀÀcÀÀ…ÀÀ©ÀÁ+ÀÁDÀÁ’ÀÁ˜ÀÁœÀÁÀÂÀÂ¤ÀÂ¥ÀÂ±ÀÂöÀÃÀÃ7ÀÃVÀÃÀÃÀÀÃòÀÄ&ÀÄ[ÀÄÀÄÀÀÄôÀÅ)ÀÅbÀÅ˜ÀÅİÀÅöÀÆDÀÆJÀÆNÀÆOÀÇ ÀÇ#ÀÇ7ÀÇMÀÇbÀÇyÀÇ‘ÀÇ§ÀÇ¼ÀÇÓÀÇëÀÈÀÈ(ÀÈGÀÈHÀÈTÀÈœÀÈ¾ÀÈàÀÈÿÀÉ6ÀÉlÀÉ¡ÀÉØÀÊÀÊCÀÊuÀÊ©ÀÊŞÀËÀËMÀË’ÀË«ÀËùÀËÿÀÌÀÌÀÌµÀÌØÀÌìÀÍÀÍÀÍ7ÀÍRÀÍhÀÍ}ÀÍ”ÀÍ¬ÀÍÏÀÍéÀÎÀÎ	ÀÎÀÎ;ÀÎ_ÀÎŒÀÎÀÎ‘ÀÎçÀÏÀÏÀÏ*ÀÏeÀÏ±ÀÏİÀĞÀĞ,ÀĞdÀĞhÀĞiÀĞuÀĞÀÀÑÀÑÀÑÀÑ*ÀÑwÀÑ™ÀÑäÀÑêÀÒ1ÀÒ5ÀÒ6ÀÒ›ÀÓÀÓÀÓÀÓdÀÓ‰ÀÓÔÀÓØÀÓÙÀÔGÀÔ¹ÀÔºÀÔÆÀÔäÀÕÀÕ6ÀÕ\ÀÕƒÀÕ¤ÀÕÄÀÕæÀÖ)ÀÖ*ÀÖRÀÖ|ÀÖÇÀÖÍÀ×À×‚À×ˆÀ×‰À×ĞÀØÀØÀØ:ÀØZÀØÀØ¤ÀØÉÀØÿÀÙ!ÀÙCÀÙyÀÙ¯ÀÙãÀÚÀÚ=ÀÚbÀÚ‰ÀÚ±ÀÚ·ÀÚ¸ÀÛ!ÀÛbÀÛšÀÛ›ÀÛÁÀÜ ÀÜfÀÜmÀÜnÀÜ‡ÀÜÕÀÜÛÀÜßÀÜàÀÜìÀİÀİ<ÀİcÀİŠÀİ´ÀİØÀİûÀŞ,ÀŞ-ÀŞUÀŞ‚ÀŞĞÀŞÖÀŞôÀßRÀßXÀß”ÀàÀàÀàKÀàLÀàrÀàÇÀáÀáÀáÀá2Àá€Àá†ÀáŠÀá‹ÀâÀâ>ÀâaÀâ{Àâ™Àâ­ÀâÎÀâçÀã ÀãÀã3Àã4Àã@Àã˜ÀãëÀãïÀãğÀä[ÀäÁÀäÂÀäÎÀåÀåÀåÀåAÀå€ÀåÀåÉÀåÍÀæÀæÀæLÀæÀæĞÀæéÀç(Àç.ÀçyÀç»ÀçÜÀèÀèÀèGÀèMÀè˜ÀèÛÀèüÀé&Àé'ÀéQÀéWÀé¦ÀéõÀê>ÀênÀêoÀê±Àê·ÀêîÀë=ÀëŒÀëÕÀëÛÀì+ÀìyÀì¦Àì¬ÀìüÀíEÀí^ÀídÀí³ÀíÈÀíôÀíõÀîEÀîhÀîzÀî{ÀîÁÀîÇÀïÀï+ÀïEÀïFÀïÀï•ÀïæÀğÀğ8Àğ:Àğ;Àğ‹ÀğÕÀğñÀğ÷Àñ-ÀñCÀñDÀñPÀñÀñ™Àñ¾ÀñòÀñøÀòÀò^Àò{Àò•Àò¦ÀòåÀòïÀòùÀó ÀóÀóÀócÀó¸Àó¹ÀóÅÀóòÀô
Àô/ÀôcÀôiÀôjÀôÀô·ÀôíÀôñÀôòÀõRÀõ˜Àõ™Àõ¥Àõ¸ÀõĞÀõàÀõøÀöÀöÀö8ÀöHÀöLÀöMÀö˜Àö½À÷À÷À÷À÷8À÷9À÷EÀ÷`À÷tÀ÷„À÷ À÷³À÷½Àø-Àø1Àø2Àø>ÀøœÀøÅÀøÆÀøÒÀøôÀøöÀø÷Àù>ÀùBÀù‡ÀùÌÀùíÀú.ÀúuÀú‘ÀúÇÀúÈÀûÀû	ÀûMÀû”ÀûËÀüÀüLÀüdÀüeÀü”ÀüšÀüåÀı5ÀızÀı”Àı–Àı—Àı÷Àş&Àş'ÀşkÀş‹ÀşŒÀş˜ÀşÃÀşÄÀşĞÀşëÀÿÀÿJÀÿPÀÿ‡Àÿ£ÀÿÂÀÿÖÀ )À pÀ •À ©À ­À ®ÀÀAÀBÀ\À]ÀiÀ¬À®À¯ÀÄÀÈÀÀÀ-À3À~ÀÉÀãÀéÀ*À0ÀÀ˜À©À×ÀöÀÀfÀgÀ—À»ÀåÀÀ7À^ÀˆÀ‰À¹À¿ÀÀ4ÀIÀJÀ‰ÀÀİÀ)ÀkÀ‚ÀƒÀÕÀğÀñÀ#À)À\ÀbÀÀ	À	8À	lÀ	pÀ	qÀ	­À	³À	æÀ
"À
#À
pÀ
vÀ
³ÀÀ)À/ÀsÀ¼ÀÀ-ÀAÀTÀjÀ­À±À²ÀÀÀ2ÀEÀYÀxÀŸÀ¦ÀªÀ«ÀÛÀáÀ*ÀoÀ“À™À¿ÀÀVÀ¡ÀíÀ;À‹ÀØÀÀ"ÀqÀ‘À¦ÀŞÀóÀ
ÀÀ.ÀOÀWÀdÀ{À–À¥À¼ÀïÀ&ÀhÀsÀ{ÀÀ…À†À¿ÀÅÀÀÀ6À„À¦À¹À¿ÀÕÀëÀÀRÀ‚À±À·ÀîÀÀÀRÀsÀyÀŒÀÀ‘ÀÀÀÀâÀõÀûÀÀ6ÀXÀƒÀ‡ÀˆÀ”ÀÒÀÓÀÀqÀÀÇÀâÀüÀÀÀ@ÀvÀwÀ‘ÀŞÀÀEÀFÀÀÆÀÇÀşÀ+À,ÀcÀÀ‘ÀàÀÀ@ÀFÀGÀ_ÀcÀdÀpÀ³ÀµÀ¶ÀıÀÀPÀfÀ¤ÀÇÀÈÀÀ+ÀlÀ±ÀãÀÀ.À2À3ÀmÀsÀ¬ÀêÀ /À xÀ ÂÀ ïÀ!7À!rÀ!£À!ßÀ!úÀ"À"@À"HÀ"qÀ"yÀ"}À"~À"¯À"µÀ"îÀ#+À#fÀ#—À#ÌÀ#çÀ$À$;À$CÀ$lÀ$tÀ$xÀ$yÀ$ÍÀ%À%À%oÀ%¼À%½À&À&eÀ&fÀ&šÀ&·À&ÆÀ&ÇÀ&æÀ&çÀ'À'À'gÀ'‚À'šÀ'ªÀ'ËÀ'ŞÀ'èÀ'ıÀ(À(À(RÀ(uÀ({À(ÈÀ)À)_À)¬À)úÀ*À*+À*;À*ZÀ*wÀ*ŠÀ*”À*¤À*¨À*©À*ôÀ+À+eÀ+À+ƒÀ+„À+ÏÀ+ÓÀ,"À,:À,[À,”À,šÀ,êÀ-<À-VÀ-\À-ªÀ-ıÀ.>À.{À.šÀ.¸À.ĞÀ.éÀ.üÀ/"À/EÀ/FÀ/‘À/ÔÀ0À0PÀ0ˆÀ0¨À0¬À0­À0×À0İÀ1À1)À1*À1UÀ1[À1–À1¨À1©À1ÛÀ1áÀ2À21À22À2‚À2¥À2«À2öÀ3À3-À3.À3|À3˜À3À3éÀ46À4GÀ4MÀ4›À4ÃÀ5À5À5À5oÀ5À5À5ÇÀ5ÍÀ6À6oÀ6‰À6À6İÀ70À7qÀ7®À7ÌÀ7êÀ8À8À8.À8TÀ8[À8oÀ8…À8ÊÀ8âÀ90À94À95À9—À9êÀ9ëÀ:TÀ:âÀ:ãÀ:òÀ:óÀ;LÀ;hÀ;iÀ;uÀ; À;¡À;±À;²À<À<)À<*À<6À<dÀ<eÀ<|À<}À<ŞÀ=À=À=À=RÀ=SÀ=_À=«À=ÆÀ=ÇÀ=ÓÀ>#À>VÀ>pÀ>vÀ>«À>ÆÀ>ÌÀ>ÍÀ?À?À?<À?zÀ?¹À?÷À@-À@3À@TÀ@vÀ@wÀ@¡À@ÜÀ@îÀ@òÀ@óÀA^ÀA´ÀAµÀAÁÀBJÀBLÀBMÀB‚ÀB²ÀB³ÀBñÀC9ÀC:ÀCrÀCvÀCÀÀCÍÀDÀDÀDRÀDnÀDÃÀDÄÀEÀE(ÀE+ÀExÀE•ÀE˜ÀEäÀEçÀEùÀEüÀFÀF;ÀF>ÀFyÀF¶ÀF»ÀF¾ÀFİÀGÀGÀGÀGÀGqÀGÇÀGóÀGöÀHLÀH€ÀH¶ÀHıÀIAÀI~ÀI”ÀIÀÀIÕÀIéÀJÀJ%ÀJeÀJmÀJzÀJ—ÀJÀJ£ÀJµÀJÌÀJèÀJìÀKÀK	ÀK
ÀKMÀK“ÀKÉÀLÀLTÀL‘ÀL§ÀLâÀL÷ÀMÀM!ÀM5ÀMkÀMzÀMÃÀMËÀMÑÀM×ÀMéÀN ÀNÀN ÀN;ÀN=ÀN>ÀNÀNÛÀNßÀO/ÀOÀO´ÀOïÀP4ÀP5ÀPjÀP‚ÀPƒÀPÕÀPğÀPñÀPıÀQÀQmÀQ†ÀQÀQåÀRÀRÀR2ÀR6ÀR8  dart.ui€¬ O_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImage_Image
_wrapImage	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_futurize_futurizeWithErrorPictureRasterizationException ù¯